{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"pgz \u00b6 pgz aim to make development of advanced pygame games easier. pgz uses pgzero as infrastructure intensively, but makes the experience more object oriented. Features \u00b6 More pytonic infrastructure: pgz utilies a lot of features from pgzero Multi-scene games: The idea and some code was taken from EzPyGame Maps, collision detection and maps scrolling: the implementation is based on pyscroll Scenes for rendering Menu based pygame-menu Multi-player game over network: based on simple RPC over WebSockets Installation \u00b6 not yet Documentation \u00b6 More detailed documentation can be found here Quick start \u00b6 pgz heavily uses concepts and some code of EzPyGame and pgzero . pgz game entry point is application, application renders scene, scene can be changed, scene manages actors. So pgz operates by 3 main concepts: Application Scene Actor Application \u00b6 The application and scenes idea was from the EzPyGame . Example of pgz application start: if __name__ == \"__main__\": app = pgz.Application( title=\"pgz Standalone Demo\", resolution=(1280, 720), update_rate=60, ) try: scene = .... app.run(scene) except Exception: # pygame.quit() raise Scene \u00b6 In the snippet above scene object instantiation scene = .... was skipped. The application and scenes idea was from the EzPyGame . Scene is the core of your game, but the active scene of you game can be changed, when you need to change the game behavior. Bassically the pgz.Application delegates all the events processing and rendering logic to the active scene. If the pgz.Application is not require subclassing, the usage of scenes is based on the subclassing idea. There are a few important method to override in pgz.Scene: handle_event(self, event: pygame.event.Event) - for processing pygame events draw(self, screen: pgz.Screen) - for rendering of the scene screen update(self, dt: float) - for modifying the scene state on_enter(self, previous_scene: pgz.Scene) - for initialization of the scene on_exit(self, next_scene: pgz.Scene) - for initialization of the scene class Game(Scene): ... def on_enter(self, previous_scene): self.previous_scene = previous_scene def update(self, dt): self.player.move(dt) if self.player.died(): self.application.change_scene(self.previous_scene) Good news that pgz provides a few pgz.Scene derived scenes for common use cases. So you can subclass from the scene implementation, which is more suitable for your game: pgz.MenuScene - implements game menu rendering as a pgz.Scene subclass pgz.ActorScene - implements the basic actors managements, updates, rendering logic and actors collision detection. pgz.MapScene - extends pgz.ActorScene for games based on the tiled maps. It also implements the tiles collision detection. pgz.RemoteSceneClient - allows to render the view of remote pgz.MapScene or pgz.ActorScene using WebSocket connection. It might be useful handy for building of a multiplayer game Actors \u00b6 Actor concept was inspired from pgzero . Actor is a sprite: alien = Actor('alien') alien.pos = 100, 56 The subclassing from the actor may be a good idea for building of the more complicated logic: class Ship(pgz.Actor): def __init__(self) -> None: super().__init__(random.choice([\"ship (1)\", \"ship (2)\", \"ship (3)\", \"ship (4)\", \"ship (5)\", \"ship (6)\"])) def update(self, dt): self._old_pos = self.pos[:] if self.keyboard.up: self.velocity[1] = -self.speed elif self.keyboard.down: self.velocity[1] = self.speed else: self.velocity[1] = 0 if self.keyboard.left: self.velocity[0] = -self.speed elif self.keyboard.right: self.velocity[0] = self.speed else: self.velocity[0] = 0 self.x += self.velocity[0] * dt self.y += self.velocity[1] * dt def move_back(self, dt): \"\"\"If called after an update, the sprite can move back\"\"\" self.pos = self._old_pos[:] Two important methods for overriding are: def draw(self, screen: Screen) -> None: pass def update(self, dt: float) -> None: pass Once actor is constructed in can be attached to ActorScene and the scene will take care of calling draw and update methods: scene.add_actor(ship) MapScene \u00b6 The usage of pgz.MapScene will require the instantiation of a map object. pgz provides a way for loading and handling Tiled maps. Map loading \u00b6 The map object loading is done with the map loader (a-la pgzero resource loaders). So for loading a map from \u201cdefault.tmx\u201d file of the resource directory: tmx = pgz.maps.default The \u201cmtx\u201d files can be created and modified with wonderful Tiled mps editor. Map management and rendering \u00b6 The maps loading and usage is backed by pyscroll pgz provides a pgz.ScrollMap class which covers listed functionality: - create and manage a pyscroll group - load a collision layers - manage sprites added to the map - allows to detect collisions with loaded collision layers - render the map and the sprites on top The code example will load tiled map, instantiate a pgz.ScrollMap object and initialize \u201cIslands\u201d layer of the tmx map as a collision layer. tmx = pgz.maps.default map = pgz.ScrollMap(app.resolution, tmx, [\"Islands\"]) Once the map object is initialized it can be used with pgz.MapScene: scene = pgz.MapScene(map) scene.add_actor(ship) ... if scene.collide_map(ship): print(\"I found an island!\") A more complete example of the pgz.MapScene subclassing: class Game(pgz.MapScene): def __init__(self, map): super().__init__(map) self.ship = Ship() # put the ship in the center of the map self.ship.position = self.map.get_center() self.ship.x += 600 self.ship.y += 400 # add our ship to the group self.add_actor(self.ship, central_actor=True) def update(self, dt): self.map.update(dt) if self.map.collide_map(self.ship): self.ship.move_back(dt) def on_mouse_move(self, pos): angle = self.ship.angle_to(pos) + 90 self.ship.angle = angle def on_mouse_down(self, pos, button): ball = CannonBall(self.ship.pos, pos, self.remove_actor) self.add_actor(ball) def on_key_down(self, key): if key == pygame.K_EQUALS: self.map.change_zoom(0.25) elif key == pygame.K_MINUS: self.map.change_zoom(-0.25) Game example \u00b6 The game example which utilizes using all the described concepts, can be fount in demo/demo_standalone.py Multiplayer game with pgz \u00b6 pgz provides two key components for converting your single-player into multiplayer-game over the network: pgz.MultiplayerSceneServer pgz.RemoteSceneClient Multiplayer game server \u00b6 MultiplayerSceneServer opens a WebSocket server and instantiate a pgz.Scene per connected player(client): tmx = pgz.maps.default map = pgz.ScrollMap((1280, 720), tmx, [\"Islands\"]) # Build and start game server self.server = pgz.MultiplayerSceneServer(map, GameScene) self.server.start_server(port=self.port) All the scenes will share the map object and collision detector object. So, the communication between different players scenes is done with collision detection. If one scene shoots the cannon ball (by implementing the CannonBall actor and adding its instance to the map): def on_mouse_down(self, pos, button): start_point = self.calc_cannon_ball_start_pos(pos) if start_point: ball = CannonBall(pos=start_point, target=pos) self.add_actor(ball, group_name=\"cannon_balls\") Another player(scene) might be harmed by the cannon ball using the collision detection: def update(self, dt): super().update(dt) cannon_ball = self.collide_group(self.ship, \"cannon_balls\") if cannon_ball: # pgz.sounds.arrr.play() self.ship.health -= cannon_ball.hit_rate * dt Multiplayer game client \u00b6 pgz.RemoteSceneClient allows to communicate with pgz.MultiplayerSceneServer and render the remote scene locally: data = self.menu.get_input_data() server_url = data[\"server_url\"] tmx = pgz.maps.default map = pgz.ScrollMap(app.resolution, tmx, [\"Islands\"]) game = pgz.RemoteSceneClient(map, server_url, client_data={\"name\": data[\"name\"]}) Pay attention that client process needs to have access to the same external resources (like map files, images,\u2026) as the game server. Multiplayer game example \u00b6 The multiplayer game example can be found in demo/demo_server.py and demo/demo_client.py Demo \u00b6","title":"Home"},{"location":"#pgz","text":"pgz aim to make development of advanced pygame games easier. pgz uses pgzero as infrastructure intensively, but makes the experience more object oriented.","title":"pgz"},{"location":"#features","text":"More pytonic infrastructure: pgz utilies a lot of features from pgzero Multi-scene games: The idea and some code was taken from EzPyGame Maps, collision detection and maps scrolling: the implementation is based on pyscroll Scenes for rendering Menu based pygame-menu Multi-player game over network: based on simple RPC over WebSockets","title":"Features"},{"location":"#installation","text":"not yet","title":"Installation"},{"location":"#documentation","text":"More detailed documentation can be found here","title":"Documentation"},{"location":"#quick-start","text":"pgz heavily uses concepts and some code of EzPyGame and pgzero . pgz game entry point is application, application renders scene, scene can be changed, scene manages actors. So pgz operates by 3 main concepts: Application Scene Actor","title":"Quick start"},{"location":"#application","text":"The application and scenes idea was from the EzPyGame . Example of pgz application start: if __name__ == \"__main__\": app = pgz.Application( title=\"pgz Standalone Demo\", resolution=(1280, 720), update_rate=60, ) try: scene = .... app.run(scene) except Exception: # pygame.quit() raise","title":"Application"},{"location":"#scene","text":"In the snippet above scene object instantiation scene = .... was skipped. The application and scenes idea was from the EzPyGame . Scene is the core of your game, but the active scene of you game can be changed, when you need to change the game behavior. Bassically the pgz.Application delegates all the events processing and rendering logic to the active scene. If the pgz.Application is not require subclassing, the usage of scenes is based on the subclassing idea. There are a few important method to override in pgz.Scene: handle_event(self, event: pygame.event.Event) - for processing pygame events draw(self, screen: pgz.Screen) - for rendering of the scene screen update(self, dt: float) - for modifying the scene state on_enter(self, previous_scene: pgz.Scene) - for initialization of the scene on_exit(self, next_scene: pgz.Scene) - for initialization of the scene class Game(Scene): ... def on_enter(self, previous_scene): self.previous_scene = previous_scene def update(self, dt): self.player.move(dt) if self.player.died(): self.application.change_scene(self.previous_scene) Good news that pgz provides a few pgz.Scene derived scenes for common use cases. So you can subclass from the scene implementation, which is more suitable for your game: pgz.MenuScene - implements game menu rendering as a pgz.Scene subclass pgz.ActorScene - implements the basic actors managements, updates, rendering logic and actors collision detection. pgz.MapScene - extends pgz.ActorScene for games based on the tiled maps. It also implements the tiles collision detection. pgz.RemoteSceneClient - allows to render the view of remote pgz.MapScene or pgz.ActorScene using WebSocket connection. It might be useful handy for building of a multiplayer game","title":"Scene"},{"location":"#actors","text":"Actor concept was inspired from pgzero . Actor is a sprite: alien = Actor('alien') alien.pos = 100, 56 The subclassing from the actor may be a good idea for building of the more complicated logic: class Ship(pgz.Actor): def __init__(self) -> None: super().__init__(random.choice([\"ship (1)\", \"ship (2)\", \"ship (3)\", \"ship (4)\", \"ship (5)\", \"ship (6)\"])) def update(self, dt): self._old_pos = self.pos[:] if self.keyboard.up: self.velocity[1] = -self.speed elif self.keyboard.down: self.velocity[1] = self.speed else: self.velocity[1] = 0 if self.keyboard.left: self.velocity[0] = -self.speed elif self.keyboard.right: self.velocity[0] = self.speed else: self.velocity[0] = 0 self.x += self.velocity[0] * dt self.y += self.velocity[1] * dt def move_back(self, dt): \"\"\"If called after an update, the sprite can move back\"\"\" self.pos = self._old_pos[:] Two important methods for overriding are: def draw(self, screen: Screen) -> None: pass def update(self, dt: float) -> None: pass Once actor is constructed in can be attached to ActorScene and the scene will take care of calling draw and update methods: scene.add_actor(ship)","title":"Actors"},{"location":"#mapscene","text":"The usage of pgz.MapScene will require the instantiation of a map object. pgz provides a way for loading and handling Tiled maps.","title":"MapScene"},{"location":"#map-loading","text":"The map object loading is done with the map loader (a-la pgzero resource loaders). So for loading a map from \u201cdefault.tmx\u201d file of the resource directory: tmx = pgz.maps.default The \u201cmtx\u201d files can be created and modified with wonderful Tiled mps editor.","title":"Map loading"},{"location":"#map-management-and-rendering","text":"The maps loading and usage is backed by pyscroll pgz provides a pgz.ScrollMap class which covers listed functionality: - create and manage a pyscroll group - load a collision layers - manage sprites added to the map - allows to detect collisions with loaded collision layers - render the map and the sprites on top The code example will load tiled map, instantiate a pgz.ScrollMap object and initialize \u201cIslands\u201d layer of the tmx map as a collision layer. tmx = pgz.maps.default map = pgz.ScrollMap(app.resolution, tmx, [\"Islands\"]) Once the map object is initialized it can be used with pgz.MapScene: scene = pgz.MapScene(map) scene.add_actor(ship) ... if scene.collide_map(ship): print(\"I found an island!\") A more complete example of the pgz.MapScene subclassing: class Game(pgz.MapScene): def __init__(self, map): super().__init__(map) self.ship = Ship() # put the ship in the center of the map self.ship.position = self.map.get_center() self.ship.x += 600 self.ship.y += 400 # add our ship to the group self.add_actor(self.ship, central_actor=True) def update(self, dt): self.map.update(dt) if self.map.collide_map(self.ship): self.ship.move_back(dt) def on_mouse_move(self, pos): angle = self.ship.angle_to(pos) + 90 self.ship.angle = angle def on_mouse_down(self, pos, button): ball = CannonBall(self.ship.pos, pos, self.remove_actor) self.add_actor(ball) def on_key_down(self, key): if key == pygame.K_EQUALS: self.map.change_zoom(0.25) elif key == pygame.K_MINUS: self.map.change_zoom(-0.25)","title":"Map management and rendering"},{"location":"#game-example","text":"The game example which utilizes using all the described concepts, can be fount in demo/demo_standalone.py","title":"Game example"},{"location":"#multiplayer-game-with-pgz","text":"pgz provides two key components for converting your single-player into multiplayer-game over the network: pgz.MultiplayerSceneServer pgz.RemoteSceneClient","title":"Multiplayer game with pgz"},{"location":"#multiplayer-game-server","text":"MultiplayerSceneServer opens a WebSocket server and instantiate a pgz.Scene per connected player(client): tmx = pgz.maps.default map = pgz.ScrollMap((1280, 720), tmx, [\"Islands\"]) # Build and start game server self.server = pgz.MultiplayerSceneServer(map, GameScene) self.server.start_server(port=self.port) All the scenes will share the map object and collision detector object. So, the communication between different players scenes is done with collision detection. If one scene shoots the cannon ball (by implementing the CannonBall actor and adding its instance to the map): def on_mouse_down(self, pos, button): start_point = self.calc_cannon_ball_start_pos(pos) if start_point: ball = CannonBall(pos=start_point, target=pos) self.add_actor(ball, group_name=\"cannon_balls\") Another player(scene) might be harmed by the cannon ball using the collision detection: def update(self, dt): super().update(dt) cannon_ball = self.collide_group(self.ship, \"cannon_balls\") if cannon_ball: # pgz.sounds.arrr.play() self.ship.health -= cannon_ball.hit_rate * dt","title":"Multiplayer game server"},{"location":"#multiplayer-game-client","text":"pgz.RemoteSceneClient allows to communicate with pgz.MultiplayerSceneServer and render the remote scene locally: data = self.menu.get_input_data() server_url = data[\"server_url\"] tmx = pgz.maps.default map = pgz.ScrollMap(app.resolution, tmx, [\"Islands\"]) game = pgz.RemoteSceneClient(map, server_url, client_data={\"name\": data[\"name\"]}) Pay attention that client process needs to have access to the same external resources (like map files, images,\u2026) as the game server.","title":"Multiplayer game client"},{"location":"#multiplayer-game-example","text":"The multiplayer game example can be found in demo/demo_server.py and demo/demo_client.py","title":"Multiplayer game example"},{"location":"#demo","text":"","title":"Demo"},{"location":"api-documentation/","text":"pgz \u00b6 pgz.actor \u00b6 pgz uses the pgzero.actor.Actor implementation a sprite representation. More inforamation can be found here pgz.application \u00b6 Application \u00b6 class Application() The idea and the original code was taken from EzPyGame A simple wrapper around pygame for running games easily. Also makes scene management seamless together with the Scene class. __init__ \u00b6 | __init__(title: Optional[str], resolution: Optional[Tuple[int, int]], update_rate: Optional[int] = None) Create an instance of the pgz.Application Arguments : title Optional[str] - title to display in the window\u2019s title bar resolution Optional[Tuple[int, int]] - resolution of the game window update_rate Optional[int], optional - how many times per second to update. Defaults to None. If any parameters are left to None , these settings must be defined either manually through application.<setting> = value or via Scene \u2018s class variable settings. Examples : class Menu(pgz.Scene): ... class Game(pgz.Scene): ... app = pgz.Application( title='My First Application', resolution=(1280, 720), update_rate=60, ) main_menu = Menu() app.run(main_menu) title \u00b6 | @property | title() -> str Get application title Returns : str - application title title \u00b6 | @title.setter | title(value: str) -> None Change application title Arguments : value str - application title to set resolution \u00b6 | @property | resolution() -> Tuple[int, int] Get application screen resolution Returns : Tuple[int, int]: application screen resolution resolution \u00b6 | @resolution.setter | resolution(value: Tuple[int, int]) -> None Change application screen resolution Arguments : value Tuple[int, int] - application screen resolution to use update_rate \u00b6 | @property | update_rate() -> int Get application update rate Returns : int - application update rate update_rate \u00b6 | @update_rate.setter | update_rate(value: int) -> None Change application update rate Arguments : value int - application update rate to set screen \u00b6 | @property | screen() -> Screen Get application screen object Returns : Screen - application screen object keyboard \u00b6 | @property | keyboard() -> Keyboard Get Keyboard object. Returns : Keyboard - keyboard object clock \u00b6 | @property | clock() -> Clock Get Clock object. Actually returns the global clock object. Returns : Clock - clock object active_scene \u00b6 | @property | active_scene() -> Optional[Scene] Get currently active scene. Can be None . Returns : Optional[Scene] - currently active scene change_scene \u00b6 | change_scene(scene: Optional[Scene]) -> None Change the currently active scene. This will invoke Scene.on_exit and Scene.on_enter methods on the switching scenes. If None is provided, the application\u2019s execution will end. Arguments : scene Optional[Scene] - the scene to change into run \u00b6 | run(scene: Optional[Scene] = None) -> None Execute the application. Arguments : scene Optional[Scene], optional - scene to start the execution from. Defaults to None. pgz.clock \u00b6 pgz uses the pgzero.clock.Clock implementation for scheduling game events. More inforamation can be found here pgz.keyboard \u00b6 pgz uses the pgzero.keyboard.Keyboard implementation for tracking the keyboard state. More inforamation can be found here Keyboard \u00b6 class Keyboard() The current state of the keyboard. Each attribute represents a key. For example, keyboard.a is True if the \u2018A\u2019 key is depressed, and False otherwise. pgz.loaders \u00b6 pgz uses the pgzero.loaders module implementation for the source managemens. More inforamation can be found here The extension was provided by pgz is the MapLoader resource loader, which loads TMX tiled maps in the same manner as all other resources are loaded Examples : The example of default.tmx file loading is shown below: tmx = pgz.maps.default pgz.multiplayer \u00b6 Set of tools for converting you singleplayer game to the multiplayer one. pgz.multiplayer.multiplayer_scene \u00b6 MultiplayerSceneServer \u00b6 class MultiplayerSceneServer() Scene server implementation. MultiplayerSceneServer opens a WebSocket server and instantiate a pgz.Scene per connected player(client): tmx = pgz.maps.default map = pgz.ScrollMap((1280, 720), tmx, [\"Islands\"]) # Build and start game server self.server = pgz.MultiplayerSceneServer(map, GameScene) self.server.start_server(port=self.port) All the scenes will share the map object and collision detector object. So, the communication between different players scenes is done with collision detection. If one scene shoots the cannon ball (by implementing the CannonBall actor and adding its instance to the map): def on_mouse_down(self, pos, button): start_point = self.calc_cannon_ball_start_pos(pos) if start_point: ball = CannonBall(pos=start_point, target=pos) self.add_actor(ball, group_name=\"cannon_balls\") Another player(scene) might be harmed by the cannon ball using the collision detection: def update(self, dt): super().update(dt) cannon_ball = self.collide_group(self.ship, \"cannon_balls\") if cannon_ball: # pgz.sounds.arrr.play() self.ship.health -= cannon_ball.hit_rate * dt __init__ \u00b6 | __init__(map: ScrollMap, HeadlessSceneClass: Scene) Create MultiplayerSceneServer instance. Arguments : map ScrollMap - a pgz.ScrollMap object. Will be shared across all the scenes in the server HeadlessSceneClass Callable - a scene class. HeadlessSceneClass will be used as a scene object factory. update \u00b6 | update(dt: float) -> None Update method similar to the pgz.scene.Scene.update method. Arguments : dt float - time in milliseconds since the last update start_server \u00b6 | start_server(host: str = \"localhost\", port: int = 8765) -> None Start the scene server. Arguments : host str, optional - host name. Defaults to \u201clocalhost\u201d. port int, optional - port number for listeting of a incoming WebSocket connections. Defaults to 8765. stop_server \u00b6 | stop_server() -> None Stop the server and disconnect all the clients RemoteSceneClient \u00b6 class RemoteSceneClient(MapScene) pgz.RemoteSceneClient allows to communicate with pgz.MultiplayerSceneServer and render the remote scene locally: data = self.menu.get_input_data() server_url = data[\"server_url\"] tmx = pgz.maps.default map = pgz.ScrollMap(app.resolution, tmx, [\"Islands\"]) game = pgz.RemoteSceneClient(map, server_url, client_data={\"name\": data[\"name\"]}) Pay attention that client process needs to have access to the same external resources (like map files, images,\u2026) as the game server. Pay attention that the RemoteSceneClient uses pgz.RPCScreenClient instead of pgz.Screen . __init__ \u00b6 | __init__(map: ScrollMap, server_url: str, client_data: JSON = {}) -> None Create a remote scene client object. client_data will be send to the remote scene object. The common usage - remote scene configuration. For example the used select the players avatar image: the image name should be a part of the client_data object. So the remote scene will be able to load a correct sprite and the actor\u2019s state with other clients. Arguments : map ScrollMap - map object will be used for actors management and rendering server_url str - remote server URL client_data JSON, optional - data will be sent to the remote scene object. Defaults to {}. on_exit \u00b6 | on_exit(next_scene: Optional[Scene]) -> None Overriden deinitialization method Arguments : next_scene Optional[Scene] - next scene to run on_enter \u00b6 | on_enter(previous_scene: Optional[Scene]) -> None Overriden initialization method Arguments : previous_scene Optional[Scene] - previous scene was running update \u00b6 | update(dt: float) -> None Overriden update method Arguments : dt float - time in milliseconds since the last update draw \u00b6 | draw(screen: Screen) -> None Overriden rendering method Arguments : screen Screen - screen to draw the scene on handle_event \u00b6 | handle_event(event: pygame.event.Event) -> None Overriden event handler Events will be accumulated internally and flushed all together to the remote scene. Arguments : event pygame.event.Event - pygame event object connect_to_server \u00b6 | async connect_to_server(attempts: int = 10) -> bool Connect to the remote scene server. Arguments : attempts int, optional - number of attempts to connect. Defaults to 10. Returns : bool - True if connected successfully pgz.multiplayer.rpc \u00b6 pgz.multiplayer.screen_rpc \u00b6 RPCSurfacePainter \u00b6 class RPCSurfacePainter() Interface to pygame.draw that is bound to a surface. line \u00b6 | line(start: Tuple[Any, Any], end: Tuple[Any, Any], color: Any, width: int = 1) -> None Draw a line from start to end. circle \u00b6 | circle(pos: Tuple[Any, Any], radius: float, color: Any, width: int = 1) -> None Draw a circle. filled_circle \u00b6 | filled_circle(pos: Tuple[Any, Any], radius: float, color: Any) -> None Draw a filled circle. polygon \u00b6 | polygon(points: List[Tuple[Any, Any]], color: Any) -> None Draw a polygon. filled_polygon \u00b6 | filled_polygon(points: List[Tuple[Any, Any]], color: Any) -> None Draw a filled polygon. rect \u00b6 | rect(rect: ZRect, color: Any, width: int = 1) -> None Draw a rectangle. filled_rect \u00b6 | filled_rect(rect: ZRect, color: Any) -> None Draw a filled rectangle. text \u00b6 | text(*args: Any, **kwargs: Any) -> None Draw text to the screen. textbox \u00b6 | textbox(*args: Any, **kwargs: Any) -> None Draw text to the screen, wrapped to fit a box RPCScreenServer \u00b6 class RPCScreenServer() bounds \u00b6 | bounds() -> ZRect Return a Rect representing the bounds of the screen. clear \u00b6 | clear() -> None Clear the screen to black. pgz.rect \u00b6 pgz uses the pgzero.rect.ZRect implementation for a rectangle representation. More inforamation can be found here pgz.scene \u00b6 Scene \u00b6 class Scene(EventDispatcher) The idea and the original code was taken from EzPyGame An isolated scene which can be ran by an application. Create your own scene by subclassing and overriding any methods. Example : class Menu(Scene): def __init__(self): self.font = pygame.font.Font(...) def on_enter(self, previous_scene): self.title = 'Main Menu' self.resolution = (640, 480) self.update_rate = 30 def draw(self, screen): pygame.draw.rect(...) text = self.font.render(...) screen.blit(text, ...) def handle_event(self, event): if event.type == pygame.MOUSEBUTTONUP: if event.button == 1: game_size = self._get_game_size(event.pos) self.change_scene(Game(game_size)) def _get_game_size(self, mouse_pos_upon_click): ... class Game(pgz.Scene): title = 'The Game!' resolution = (1280, 720) update_rate = 60 def __init__(self, size): super().__init__() self.size = size self.player = ... ... def on_enter(self, previous_scene): super().on_enter(previous_scene) self.previous_scene = previous_scene def draw(self, screen): self.player.draw(screen) for enemy in self.enemies: ... def update(self, dt): self.player.move(dt) ... if self.player.is_dead(): self.change_scene(self.previous_scene) elif self.player_won(): self.change_scene(...) def handle_event(self, event): ... # Player movement etc. The above two classes use different approaches for changing the application\u2019s settings when the scene is entered: Manually set them in on_enter , as seen in Menu Use class variables, as I did with Game When using class variables (2), you can leave out any setting (defaults to None ) to not override that particular setting. If you override on_enter in the subclass, you must call super().on_enter(previous_scene) to use the class variables. These settings can further be overridden in individual instances: my_scene0 = MyScene() my_scene0.resolution = (1280, 720) my_scene1 = MyScene(title='My Second Awesome Scene') Example : Shortcuts foe event gandling while Scene subclassing. def on_mouse_up(self, pos, button): # Override this for easier events handling. pass def on_mouse_down(self, pos, button): # Override this for easier events handling. pass def on_mouse_move(self, pos): # Override this for easier events handling. pass def on_key_down(self, key): # Override this for easier events handling. pass def on_key_up(self, key): # Override this for easier events handling. pass scene_uuid \u00b6 | @property | scene_uuid() -> str Get scene UUID. client_data \u00b6 | @property | client_data() -> Dict[str, Any] Get data provided by client side. title \u00b6 | @property | title() -> str Get application title Returns : str - application title title \u00b6 | @title.setter | title(value: str) -> None Change application title Arguments : value str - application title to set resolution \u00b6 | @property | resolution() -> Tuple[int, int] Get application screen resolution Returns : Tuple[int, int]: application screen resolution resolution \u00b6 | @resolution.setter | resolution(value: Tuple[int, int]) -> None Change application screen resolution Arguments : value Tuple[int, int] - application screen resolution to use update_rate \u00b6 | @property | update_rate() -> int Get application update rate Returns : int - application update rate update_rate \u00b6 | @update_rate.setter | update_rate(value: int) -> None Change application update rate Arguments : value int - application update rate to set clock \u00b6 | @property | clock() -> Clock Get Clock object. Actually returns the global clock object. Returns : Clock - clock object keyboard \u00b6 | @property | keyboard() -> Keyboard Get Keyboard object. Returns : Keyboard - keyboard object draw \u00b6 | draw(screen: Screen) -> None Override this with the scene drawing. Arguments : screen Screen - screen to draw the scene on update \u00b6 | update(dt: float) -> None Override this with the scene update tick. Arguments : dt float - time in milliseconds since the last update handle_event \u00b6 | handle_event(event: pygame.event.Event) -> None Override this to handle an event in the scene. All of pygame \u2018s events are sent here, so filtering should be applied manually in the subclass. Arguments : event pygame.event.Event - event to handle on_enter \u00b6 | on_enter(previous_scene: Optional[\"Scene\"]) -> None Override this to initialize upon scene entering. If you override this method and want to use class variables to change the application\u2019s settings, you must call super().on_enter(previous_scene) in the subclass. Arguments : previous_scene Optional[Scene] - previous scene was running on_exit \u00b6 | on_exit(next_scene: Optional[\"Scene\"]) -> None Override this to deinitialize upon scene exiting. Arguments : next_scene Optional[Scene] - next scene to run pgz.scenes \u00b6 pgz provides an implementation of a few tipical scene classes subclassed from the pgz.Scene . pgz.MenuScene - implements game menu rendering as a pgz.Scene subclass pgz.ActorScene - implements the basic actors managements, updates, rendering logic and actors collision detection. pgz.MapScene - extends pgz.ActorScene for games based on the tiled maps. It also implements the tiles collision detection. pgz.RemoteSceneClient - allows to render the view of remote pgz.MapScene or pgz.ActorScene using WebSocket connection. It might be useful handy for building of a multiplayer game pgz.scenes.actor_scene \u00b6 ActorScene \u00b6 class ActorScene(Scene) Scene implementation for management of multiple actors. Actors also can be added to different collision groups, which allows easily identify collision of an actor with a specific actor group. __init__ \u00b6 | __init__() -> None Create an ActorScene object set_collision_detector \u00b6 | set_collision_detector(collision_detector: CollisionDetector) Set external collsinion detector object. The default collision detector can be use in the most of the cases. This method in used by multiplayer. add_actor \u00b6 | add_actor(actor: Actor, group_name: str = \"\") -> None Add actor to the scene and add the actor to the collision group. Arguments : actor Actor - actor to add group_name str, optional - Collision group name. Defaults to \u201c\u201d. remove_actor \u00b6 | remove_actor(actor: Actor) -> None Remove actor from the scene. Actor also will be removed from the associated collision detector Arguments : actor Actor - Actor to be removed remove_actors \u00b6 | remove_actors() -> None Remove all actors from the scene and the associated collision detector get_actor \u00b6 | get_actor(uuid: str) -> Actor Get actor object by its UUID Arguments : uuid str - UUID of the actor to be retrieved Returns : Actor - Actor associated with the UUID get_actors \u00b6 | get_actors() -> List[Actor] Get list of actors Returns : List[Actor] - The list of actors on the scene collide_group \u00b6 | collide_group(actor: Actor, group_name: str = \"\") -> Optional[Actor] Detect collision of a ginen actor with the actors in requested collsion group. Arguments : actor Actor - actor to detect collisions with group_name str, optional - Collision group name. Defaults to \u201c\u201d. Returns : Optional[Actor] - A collins actor in the specified collision group draw \u00b6 | draw(surface: Screen) -> None Overriden rendering method Implementation of the update method for the ActorScene. The ActorScene implementation renders all the actorts attached to the scene. Arguments : screen Screen - screen to draw the scene on update \u00b6 | update(dt: float) -> None Overriden update method Implementation of the update method for the ActorScene. This method updates all the actors attached to the scene. Arguments : dt float - time in milliseconds since the last update pgz.scenes.map_scene \u00b6 MapScene \u00b6 class MapScene(ActorScene) Scene implementation for Tiled map management. Extends functionality ActorScene, but in case of MapScene actors are placed on a map. The implementation is based on pyscroll . A tiled map can be created and modified with wonderful Tiled maps editor. The maps loading and usage is backed by PyTMX Actors also can be added to different collision groups, which allows easily identify collision of an actor with a specific actor group __init__ \u00b6 | __init__(map: Optional[ScrollMap] = None) Create a MapScene object The map object loading is done with the map loader (a-la pgzero resource loaders). So for loading a map from \u201cdefault.tmx\u201d file of the resource directory: tmx = pgz.maps.default map = pgz.ScrollMap(app.resolution, tmx, [\"Islands\"]) Arguments : map Optional[ScrollMap], optional - Loaded map object. Defaults to None. map \u00b6 | @property | map() -> ScrollMap Get map object Returns : ScrollMap - the map object used by the scene set_map \u00b6 | set_map(map) Set map object Arguments : map [type] - map object to set dispatch_event \u00b6 | dispatch_event(event: pygame.event.Event) -> None Overriden events dispatch method Used for mouse cursor position transformation into map \u201cworld coordinates\u201d Arguments : event pygame.event.Event - pygame Event object update \u00b6 | update(dt: float) -> None Overriden update method Implementation of the update method for the MapScene. This method updates all the actors attached to the scene. Arguments : dt float - time in milliseconds since the last update draw \u00b6 | draw(screen: Screen) -> None Overriden rendering method Implementation of the update method for the MapScene. The ActorScene implementation renders all the actorts attached to the scene. Arguments : screen Screen - screen to draw the scene on add_actor \u00b6 | add_actor(actor: Actor, central_actor: bool = False, group_name: str = \"\") -> None Overriden add_actor method Implementation of the add_actor method for the MapScene. The ActorScene implementation renders all the actorts attached to the scene. Arguments : actor Actor - actor to add central_actor bool, optional - Sets the actor to be central actor for the scene. The map view will be centered on the actor. Defaults to False. group_name str, optional - Collision group name. Defaults to \u201c\u201d. remove_actor \u00b6 | remove_actor(actor: Actor) -> None Overriden remove_actor method Implementation of the remove_actor method for the MapScene. Arguments : actor Actor - actor to be removed handle_event \u00b6 | handle_event(event: pygame.event.Event) -> None Overriden event handler Implementation of the event handler method for the MapScene. Arguments : event pygame.event.Event - pygame event object collide_map \u00b6 | collide_map(actor: Actor) -> bool Detect collision with tiles in the map object used by the scene Arguments : actor Actor - actor for collision detection Returns : bool - True if the collision with map tiles is detected pgz.scenes.menu_scene \u00b6 MenuScene \u00b6 class MenuScene(Scene) Base class for a scenes showing menu. MenuScene uses pygame_menu.Menu internally, for the additional information follow the link pygame-menu . Examples : class Menu(pgz.MenuScene): def __init__(self): super().__init__() import pygame_menu self.menu = pygame_menu.Menu(300, 400, \"Welcome\", theme=pygame_menu.themes.THEME_BLUE) self.menu.add_text_input(\"Name :\", textinput_id=\"name\", default=\"John Doe\") self.menu.add_selector('Difficulty :', [('Hard', 1), ('Easy', 2)], onchange=set_difficulty) self.menu.add_button(\"Play\", self.start_the_game) self.menu.add_button(\"Quit\", pygame_menu.events.EXIT) def start_the_game(self): data = self.menu.get_input_data() scene = GameScene() tmx = pgz.maps.default map = pgz.ScrollMap(app.resolution, tmx, [\"Islands\"]) scene.set_map(map) scene.set_client_data({\"name\": data[\"name\"]}) self.change_scene(scene) __init__ \u00b6 | __init__(menu: Optional[pygame_menu.Menu] = None) Create MenuScene Receives a menu object as argument or creates its own menu object. Arguments : menu Optional[pygame_menu.Menu], optional - menu object. Defaults to None. menu \u00b6 | @property | menu() -> pygame_menu.Menu Get the internal pygame_menu.Menu object. Returns : pygame_menu.Menu - internal menu object. draw \u00b6 | draw(screen: Screen) -> None Overriden rendering method Implementation of the update method for the ActorScene. The ActorScene implementation renders all the actorts attached to the scene. Arguments : screen Screen - screen to draw the scene on on_exit \u00b6 | on_exit(next_scene: Optional[Scene]) -> None Overriden deinitialization method Arguments : next_scene Optional[Scene] - next scene to run handle_event \u00b6 | handle_event(event: pygame.event.Event) -> None Overriden event handling method method All of pygame \u2018s events are sent here, so filtering should be applied manually in the subclass. Arguments : event pygame.event.Event - event to handle pgz.screen \u00b6 pgz uses the pgzero.screen.Screen implementation for the screen object representation and rendering. More inforamation can be found here . pgz.utils \u00b6 pgz.utils.collision_detector \u00b6 CollisionDetector \u00b6 class CollisionDetector(object) Class helper for easier collision detection The class manages multiple collision groups and can detect a collsion with each one of groups independently. __init__ \u00b6 | __init__() -> None Create a collision detecor add_actor \u00b6 | add_actor(actor: Actor, group_name: str = \"\") -> None Add an actor to the detector Arguments : actor Actor - actor to add group_name str, optional - collision group to use. Defaults to \u201c\u201d. remove_actor \u00b6 | remove_actor(actor: Actor) -> None Remore an actor from the detector and all collision groups Arguments : actor Actor - actor to remove get_actor \u00b6 | get_actor(uuid: str) -> Actor Get actor by UUID Arguments : uuid str - UUID of the actor Returns : Actor - actor associated with the UUID get_actors \u00b6 | get_actors() -> List[Actor] Get list of all the known actors. Returns : List[Actor] - list of actors collide_group \u00b6 | collide_group(sprite: pygame.sprite.Sprite, group_name: str = \"\") -> Optional[pygame.sprite.Sprite] Detect a collision of an actor with a specified collsion group. Arguments : sprite pygame.sprite.Sprite - actor to use for collision detection. group_name str, optional - collision group name. Defaults to \u201c\u201d. Returns : Optional[pygame.sprite.Sprite] - actor was found in the collsion group. pgz.utils.event_dispatcher \u00b6 EventDispatcher \u00b6 class EventDispatcher() Adapt a pgzero game\u2019s raw handler function to take a Pygame Event. Returns a one-argument function of the form handler(event) . This will ensure that the correct arguments are passed to the raw handler based on its argument spec. The wrapped handler will also map certain parameter values using callables from EVENT_PARAM_MAPPERS; this ensures that the value of \u2018button\u2019 inside the handler is a real instance of constants.mouse, which means (among other things) that it will print as a symbolic value rather than a naive integer. handle_event \u00b6 | handle_event(event: pygame.event.Event) -> None Override me pgz.utils.fps_calc \u00b6 pgz.utils.scroll_map \u00b6 ScrollMap \u00b6 class ScrollMap(object) Scroll Map object. The implementation is based on pyscroll This class provides functionality: - create and manage a pyscroll group - load a collision layers - manage sprites added to the map - allows to detect collisions with loaded collision layers - render the map and the sprites on top __init__ \u00b6 | __init__(screen_size: Tuple[int, int], tmx: pytmx.TiledMap, collision_layers: List[str] = []) -> None Create scroll map object. Arguments : screen_size Tuple[int, int] - screen resolution will be used to the map rendering tmx pytmx.TiledMap - loaded pytmx.TiledMap object collision_layers List[str], optional - List of pytmx.TiledMap layer names will be used for tiles collision detection. Defaults to []. add_collision_layers \u00b6 | add_collision_layers(collision_layers: List[str]) -> None Load pytmx.TiledMap layer tiles for collision detection. Some layer in the pytmx.TiledMap might be be used for collision detection. For example: the layer includes \u201cisland tiles\u201d might be used for collision detection with a \u201cship\u201d actor. Arguments : collision_layers List[str] - List of pytmx.TiledMap layer names will be used for tiles collision detection. draw \u00b6 | draw(screen: Screen) -> None Draw method similar to the pgz.scene.Scene.draw method. Will draw the map and all actors on top. Arguments : dt float - time in milliseconds since the last update update \u00b6 | update(dt: float) -> None Update method similar to the pgz.scene.Scene.update method. All the actors attached to the map will be updated. Arguments : dt float - time in milliseconds since the last update add_sprite \u00b6 | add_sprite(sprite: pygame.sprite.Sprite) -> None Add actor/sprite to the map Arguments : sprite pygame.sprite.Sprite - sprite object to add remove_sprite \u00b6 | remove_sprite(sprite: pygame.sprite.Sprite) -> None Remove sprite/actor from the map. Arguments : sprite pygame.sprite.Sprite - sprite object to remove collide_map \u00b6 | collide_map(sprite: pygame.sprite.Sprite) -> bool Detect a collision with tiles on the map Arguments : sprite pygame.sprite.Sprite - sprite/actor for detection Returns : bool - True is the collision with the colision layers was detected","title":"API Documentation"},{"location":"api-documentation/#pgz","text":"","title":"pgz"},{"location":"api-documentation/#pgzactor","text":"pgz uses the pgzero.actor.Actor implementation a sprite representation. More inforamation can be found here","title":"pgz.actor"},{"location":"api-documentation/#pgzapplication","text":"","title":"pgz.application"},{"location":"api-documentation/#application","text":"class Application() The idea and the original code was taken from EzPyGame A simple wrapper around pygame for running games easily. Also makes scene management seamless together with the Scene class.","title":"Application"},{"location":"api-documentation/#__init__","text":"| __init__(title: Optional[str], resolution: Optional[Tuple[int, int]], update_rate: Optional[int] = None) Create an instance of the pgz.Application Arguments : title Optional[str] - title to display in the window\u2019s title bar resolution Optional[Tuple[int, int]] - resolution of the game window update_rate Optional[int], optional - how many times per second to update. Defaults to None. If any parameters are left to None , these settings must be defined either manually through application.<setting> = value or via Scene \u2018s class variable settings. Examples : class Menu(pgz.Scene): ... class Game(pgz.Scene): ... app = pgz.Application( title='My First Application', resolution=(1280, 720), update_rate=60, ) main_menu = Menu() app.run(main_menu)","title":"__init__"},{"location":"api-documentation/#title","text":"| @property | title() -> str Get application title Returns : str - application title","title":"title"},{"location":"api-documentation/#title_1","text":"| @title.setter | title(value: str) -> None Change application title Arguments : value str - application title to set","title":"title"},{"location":"api-documentation/#resolution","text":"| @property | resolution() -> Tuple[int, int] Get application screen resolution Returns : Tuple[int, int]: application screen resolution","title":"resolution"},{"location":"api-documentation/#resolution_1","text":"| @resolution.setter | resolution(value: Tuple[int, int]) -> None Change application screen resolution Arguments : value Tuple[int, int] - application screen resolution to use","title":"resolution"},{"location":"api-documentation/#update_rate","text":"| @property | update_rate() -> int Get application update rate Returns : int - application update rate","title":"update_rate"},{"location":"api-documentation/#update_rate_1","text":"| @update_rate.setter | update_rate(value: int) -> None Change application update rate Arguments : value int - application update rate to set","title":"update_rate"},{"location":"api-documentation/#screen","text":"| @property | screen() -> Screen Get application screen object Returns : Screen - application screen object","title":"screen"},{"location":"api-documentation/#keyboard","text":"| @property | keyboard() -> Keyboard Get Keyboard object. Returns : Keyboard - keyboard object","title":"keyboard"},{"location":"api-documentation/#clock","text":"| @property | clock() -> Clock Get Clock object. Actually returns the global clock object. Returns : Clock - clock object","title":"clock"},{"location":"api-documentation/#active_scene","text":"| @property | active_scene() -> Optional[Scene] Get currently active scene. Can be None . Returns : Optional[Scene] - currently active scene","title":"active_scene"},{"location":"api-documentation/#change_scene","text":"| change_scene(scene: Optional[Scene]) -> None Change the currently active scene. This will invoke Scene.on_exit and Scene.on_enter methods on the switching scenes. If None is provided, the application\u2019s execution will end. Arguments : scene Optional[Scene] - the scene to change into","title":"change_scene"},{"location":"api-documentation/#run","text":"| run(scene: Optional[Scene] = None) -> None Execute the application. Arguments : scene Optional[Scene], optional - scene to start the execution from. Defaults to None.","title":"run"},{"location":"api-documentation/#pgzclock","text":"pgz uses the pgzero.clock.Clock implementation for scheduling game events. More inforamation can be found here","title":"pgz.clock"},{"location":"api-documentation/#pgzkeyboard","text":"pgz uses the pgzero.keyboard.Keyboard implementation for tracking the keyboard state. More inforamation can be found here","title":"pgz.keyboard"},{"location":"api-documentation/#keyboard_1","text":"class Keyboard() The current state of the keyboard. Each attribute represents a key. For example, keyboard.a is True if the \u2018A\u2019 key is depressed, and False otherwise.","title":"Keyboard"},{"location":"api-documentation/#pgzloaders","text":"pgz uses the pgzero.loaders module implementation for the source managemens. More inforamation can be found here The extension was provided by pgz is the MapLoader resource loader, which loads TMX tiled maps in the same manner as all other resources are loaded Examples : The example of default.tmx file loading is shown below: tmx = pgz.maps.default","title":"pgz.loaders"},{"location":"api-documentation/#pgzmultiplayer","text":"Set of tools for converting you singleplayer game to the multiplayer one.","title":"pgz.multiplayer"},{"location":"api-documentation/#pgzmultiplayermultiplayer_scene","text":"","title":"pgz.multiplayer.multiplayer_scene"},{"location":"api-documentation/#multiplayersceneserver","text":"class MultiplayerSceneServer() Scene server implementation. MultiplayerSceneServer opens a WebSocket server and instantiate a pgz.Scene per connected player(client): tmx = pgz.maps.default map = pgz.ScrollMap((1280, 720), tmx, [\"Islands\"]) # Build and start game server self.server = pgz.MultiplayerSceneServer(map, GameScene) self.server.start_server(port=self.port) All the scenes will share the map object and collision detector object. So, the communication between different players scenes is done with collision detection. If one scene shoots the cannon ball (by implementing the CannonBall actor and adding its instance to the map): def on_mouse_down(self, pos, button): start_point = self.calc_cannon_ball_start_pos(pos) if start_point: ball = CannonBall(pos=start_point, target=pos) self.add_actor(ball, group_name=\"cannon_balls\") Another player(scene) might be harmed by the cannon ball using the collision detection: def update(self, dt): super().update(dt) cannon_ball = self.collide_group(self.ship, \"cannon_balls\") if cannon_ball: # pgz.sounds.arrr.play() self.ship.health -= cannon_ball.hit_rate * dt","title":"MultiplayerSceneServer"},{"location":"api-documentation/#__init___1","text":"| __init__(map: ScrollMap, HeadlessSceneClass: Scene) Create MultiplayerSceneServer instance. Arguments : map ScrollMap - a pgz.ScrollMap object. Will be shared across all the scenes in the server HeadlessSceneClass Callable - a scene class. HeadlessSceneClass will be used as a scene object factory.","title":"__init__"},{"location":"api-documentation/#update","text":"| update(dt: float) -> None Update method similar to the pgz.scene.Scene.update method. Arguments : dt float - time in milliseconds since the last update","title":"update"},{"location":"api-documentation/#start_server","text":"| start_server(host: str = \"localhost\", port: int = 8765) -> None Start the scene server. Arguments : host str, optional - host name. Defaults to \u201clocalhost\u201d. port int, optional - port number for listeting of a incoming WebSocket connections. Defaults to 8765.","title":"start_server"},{"location":"api-documentation/#stop_server","text":"| stop_server() -> None Stop the server and disconnect all the clients","title":"stop_server"},{"location":"api-documentation/#remotesceneclient","text":"class RemoteSceneClient(MapScene) pgz.RemoteSceneClient allows to communicate with pgz.MultiplayerSceneServer and render the remote scene locally: data = self.menu.get_input_data() server_url = data[\"server_url\"] tmx = pgz.maps.default map = pgz.ScrollMap(app.resolution, tmx, [\"Islands\"]) game = pgz.RemoteSceneClient(map, server_url, client_data={\"name\": data[\"name\"]}) Pay attention that client process needs to have access to the same external resources (like map files, images,\u2026) as the game server. Pay attention that the RemoteSceneClient uses pgz.RPCScreenClient instead of pgz.Screen .","title":"RemoteSceneClient"},{"location":"api-documentation/#__init___2","text":"| __init__(map: ScrollMap, server_url: str, client_data: JSON = {}) -> None Create a remote scene client object. client_data will be send to the remote scene object. The common usage - remote scene configuration. For example the used select the players avatar image: the image name should be a part of the client_data object. So the remote scene will be able to load a correct sprite and the actor\u2019s state with other clients. Arguments : map ScrollMap - map object will be used for actors management and rendering server_url str - remote server URL client_data JSON, optional - data will be sent to the remote scene object. Defaults to {}.","title":"__init__"},{"location":"api-documentation/#on_exit","text":"| on_exit(next_scene: Optional[Scene]) -> None Overriden deinitialization method Arguments : next_scene Optional[Scene] - next scene to run","title":"on_exit"},{"location":"api-documentation/#on_enter","text":"| on_enter(previous_scene: Optional[Scene]) -> None Overriden initialization method Arguments : previous_scene Optional[Scene] - previous scene was running","title":"on_enter"},{"location":"api-documentation/#update_1","text":"| update(dt: float) -> None Overriden update method Arguments : dt float - time in milliseconds since the last update","title":"update"},{"location":"api-documentation/#draw","text":"| draw(screen: Screen) -> None Overriden rendering method Arguments : screen Screen - screen to draw the scene on","title":"draw"},{"location":"api-documentation/#handle_event","text":"| handle_event(event: pygame.event.Event) -> None Overriden event handler Events will be accumulated internally and flushed all together to the remote scene. Arguments : event pygame.event.Event - pygame event object","title":"handle_event"},{"location":"api-documentation/#connect_to_server","text":"| async connect_to_server(attempts: int = 10) -> bool Connect to the remote scene server. Arguments : attempts int, optional - number of attempts to connect. Defaults to 10. Returns : bool - True if connected successfully","title":"connect_to_server"},{"location":"api-documentation/#pgzmultiplayerrpc","text":"","title":"pgz.multiplayer.rpc"},{"location":"api-documentation/#pgzmultiplayerscreen_rpc","text":"","title":"pgz.multiplayer.screen_rpc"},{"location":"api-documentation/#rpcsurfacepainter","text":"class RPCSurfacePainter() Interface to pygame.draw that is bound to a surface.","title":"RPCSurfacePainter"},{"location":"api-documentation/#line","text":"| line(start: Tuple[Any, Any], end: Tuple[Any, Any], color: Any, width: int = 1) -> None Draw a line from start to end.","title":"line"},{"location":"api-documentation/#circle","text":"| circle(pos: Tuple[Any, Any], radius: float, color: Any, width: int = 1) -> None Draw a circle.","title":"circle"},{"location":"api-documentation/#filled_circle","text":"| filled_circle(pos: Tuple[Any, Any], radius: float, color: Any) -> None Draw a filled circle.","title":"filled_circle"},{"location":"api-documentation/#polygon","text":"| polygon(points: List[Tuple[Any, Any]], color: Any) -> None Draw a polygon.","title":"polygon"},{"location":"api-documentation/#filled_polygon","text":"| filled_polygon(points: List[Tuple[Any, Any]], color: Any) -> None Draw a filled polygon.","title":"filled_polygon"},{"location":"api-documentation/#rect","text":"| rect(rect: ZRect, color: Any, width: int = 1) -> None Draw a rectangle.","title":"rect"},{"location":"api-documentation/#filled_rect","text":"| filled_rect(rect: ZRect, color: Any) -> None Draw a filled rectangle.","title":"filled_rect"},{"location":"api-documentation/#text","text":"| text(*args: Any, **kwargs: Any) -> None Draw text to the screen.","title":"text"},{"location":"api-documentation/#textbox","text":"| textbox(*args: Any, **kwargs: Any) -> None Draw text to the screen, wrapped to fit a box","title":"textbox"},{"location":"api-documentation/#rpcscreenserver","text":"class RPCScreenServer()","title":"RPCScreenServer"},{"location":"api-documentation/#bounds","text":"| bounds() -> ZRect Return a Rect representing the bounds of the screen.","title":"bounds"},{"location":"api-documentation/#clear","text":"| clear() -> None Clear the screen to black.","title":"clear"},{"location":"api-documentation/#pgzrect","text":"pgz uses the pgzero.rect.ZRect implementation for a rectangle representation. More inforamation can be found here","title":"pgz.rect"},{"location":"api-documentation/#pgzscene","text":"","title":"pgz.scene"},{"location":"api-documentation/#scene","text":"class Scene(EventDispatcher) The idea and the original code was taken from EzPyGame An isolated scene which can be ran by an application. Create your own scene by subclassing and overriding any methods. Example : class Menu(Scene): def __init__(self): self.font = pygame.font.Font(...) def on_enter(self, previous_scene): self.title = 'Main Menu' self.resolution = (640, 480) self.update_rate = 30 def draw(self, screen): pygame.draw.rect(...) text = self.font.render(...) screen.blit(text, ...) def handle_event(self, event): if event.type == pygame.MOUSEBUTTONUP: if event.button == 1: game_size = self._get_game_size(event.pos) self.change_scene(Game(game_size)) def _get_game_size(self, mouse_pos_upon_click): ... class Game(pgz.Scene): title = 'The Game!' resolution = (1280, 720) update_rate = 60 def __init__(self, size): super().__init__() self.size = size self.player = ... ... def on_enter(self, previous_scene): super().on_enter(previous_scene) self.previous_scene = previous_scene def draw(self, screen): self.player.draw(screen) for enemy in self.enemies: ... def update(self, dt): self.player.move(dt) ... if self.player.is_dead(): self.change_scene(self.previous_scene) elif self.player_won(): self.change_scene(...) def handle_event(self, event): ... # Player movement etc. The above two classes use different approaches for changing the application\u2019s settings when the scene is entered: Manually set them in on_enter , as seen in Menu Use class variables, as I did with Game When using class variables (2), you can leave out any setting (defaults to None ) to not override that particular setting. If you override on_enter in the subclass, you must call super().on_enter(previous_scene) to use the class variables. These settings can further be overridden in individual instances: my_scene0 = MyScene() my_scene0.resolution = (1280, 720) my_scene1 = MyScene(title='My Second Awesome Scene') Example : Shortcuts foe event gandling while Scene subclassing. def on_mouse_up(self, pos, button): # Override this for easier events handling. pass def on_mouse_down(self, pos, button): # Override this for easier events handling. pass def on_mouse_move(self, pos): # Override this for easier events handling. pass def on_key_down(self, key): # Override this for easier events handling. pass def on_key_up(self, key): # Override this for easier events handling. pass","title":"Scene"},{"location":"api-documentation/#scene_uuid","text":"| @property | scene_uuid() -> str Get scene UUID.","title":"scene_uuid"},{"location":"api-documentation/#client_data","text":"| @property | client_data() -> Dict[str, Any] Get data provided by client side.","title":"client_data"},{"location":"api-documentation/#title_2","text":"| @property | title() -> str Get application title Returns : str - application title","title":"title"},{"location":"api-documentation/#title_3","text":"| @title.setter | title(value: str) -> None Change application title Arguments : value str - application title to set","title":"title"},{"location":"api-documentation/#resolution_2","text":"| @property | resolution() -> Tuple[int, int] Get application screen resolution Returns : Tuple[int, int]: application screen resolution","title":"resolution"},{"location":"api-documentation/#resolution_3","text":"| @resolution.setter | resolution(value: Tuple[int, int]) -> None Change application screen resolution Arguments : value Tuple[int, int] - application screen resolution to use","title":"resolution"},{"location":"api-documentation/#update_rate_2","text":"| @property | update_rate() -> int Get application update rate Returns : int - application update rate","title":"update_rate"},{"location":"api-documentation/#update_rate_3","text":"| @update_rate.setter | update_rate(value: int) -> None Change application update rate Arguments : value int - application update rate to set","title":"update_rate"},{"location":"api-documentation/#clock_1","text":"| @property | clock() -> Clock Get Clock object. Actually returns the global clock object. Returns : Clock - clock object","title":"clock"},{"location":"api-documentation/#keyboard_2","text":"| @property | keyboard() -> Keyboard Get Keyboard object. Returns : Keyboard - keyboard object","title":"keyboard"},{"location":"api-documentation/#draw_1","text":"| draw(screen: Screen) -> None Override this with the scene drawing. Arguments : screen Screen - screen to draw the scene on","title":"draw"},{"location":"api-documentation/#update_2","text":"| update(dt: float) -> None Override this with the scene update tick. Arguments : dt float - time in milliseconds since the last update","title":"update"},{"location":"api-documentation/#handle_event_1","text":"| handle_event(event: pygame.event.Event) -> None Override this to handle an event in the scene. All of pygame \u2018s events are sent here, so filtering should be applied manually in the subclass. Arguments : event pygame.event.Event - event to handle","title":"handle_event"},{"location":"api-documentation/#on_enter_1","text":"| on_enter(previous_scene: Optional[\"Scene\"]) -> None Override this to initialize upon scene entering. If you override this method and want to use class variables to change the application\u2019s settings, you must call super().on_enter(previous_scene) in the subclass. Arguments : previous_scene Optional[Scene] - previous scene was running","title":"on_enter"},{"location":"api-documentation/#on_exit_1","text":"| on_exit(next_scene: Optional[\"Scene\"]) -> None Override this to deinitialize upon scene exiting. Arguments : next_scene Optional[Scene] - next scene to run","title":"on_exit"},{"location":"api-documentation/#pgzscenes","text":"pgz provides an implementation of a few tipical scene classes subclassed from the pgz.Scene . pgz.MenuScene - implements game menu rendering as a pgz.Scene subclass pgz.ActorScene - implements the basic actors managements, updates, rendering logic and actors collision detection. pgz.MapScene - extends pgz.ActorScene for games based on the tiled maps. It also implements the tiles collision detection. pgz.RemoteSceneClient - allows to render the view of remote pgz.MapScene or pgz.ActorScene using WebSocket connection. It might be useful handy for building of a multiplayer game","title":"pgz.scenes"},{"location":"api-documentation/#pgzscenesactor_scene","text":"","title":"pgz.scenes.actor_scene"},{"location":"api-documentation/#actorscene","text":"class ActorScene(Scene) Scene implementation for management of multiple actors. Actors also can be added to different collision groups, which allows easily identify collision of an actor with a specific actor group.","title":"ActorScene"},{"location":"api-documentation/#__init___3","text":"| __init__() -> None Create an ActorScene object","title":"__init__"},{"location":"api-documentation/#set_collision_detector","text":"| set_collision_detector(collision_detector: CollisionDetector) Set external collsinion detector object. The default collision detector can be use in the most of the cases. This method in used by multiplayer.","title":"set_collision_detector"},{"location":"api-documentation/#add_actor","text":"| add_actor(actor: Actor, group_name: str = \"\") -> None Add actor to the scene and add the actor to the collision group. Arguments : actor Actor - actor to add group_name str, optional - Collision group name. Defaults to \u201c\u201d.","title":"add_actor"},{"location":"api-documentation/#remove_actor","text":"| remove_actor(actor: Actor) -> None Remove actor from the scene. Actor also will be removed from the associated collision detector Arguments : actor Actor - Actor to be removed","title":"remove_actor"},{"location":"api-documentation/#remove_actors","text":"| remove_actors() -> None Remove all actors from the scene and the associated collision detector","title":"remove_actors"},{"location":"api-documentation/#get_actor","text":"| get_actor(uuid: str) -> Actor Get actor object by its UUID Arguments : uuid str - UUID of the actor to be retrieved Returns : Actor - Actor associated with the UUID","title":"get_actor"},{"location":"api-documentation/#get_actors","text":"| get_actors() -> List[Actor] Get list of actors Returns : List[Actor] - The list of actors on the scene","title":"get_actors"},{"location":"api-documentation/#collide_group","text":"| collide_group(actor: Actor, group_name: str = \"\") -> Optional[Actor] Detect collision of a ginen actor with the actors in requested collsion group. Arguments : actor Actor - actor to detect collisions with group_name str, optional - Collision group name. Defaults to \u201c\u201d. Returns : Optional[Actor] - A collins actor in the specified collision group","title":"collide_group"},{"location":"api-documentation/#draw_2","text":"| draw(surface: Screen) -> None Overriden rendering method Implementation of the update method for the ActorScene. The ActorScene implementation renders all the actorts attached to the scene. Arguments : screen Screen - screen to draw the scene on","title":"draw"},{"location":"api-documentation/#update_3","text":"| update(dt: float) -> None Overriden update method Implementation of the update method for the ActorScene. This method updates all the actors attached to the scene. Arguments : dt float - time in milliseconds since the last update","title":"update"},{"location":"api-documentation/#pgzscenesmap_scene","text":"","title":"pgz.scenes.map_scene"},{"location":"api-documentation/#mapscene","text":"class MapScene(ActorScene) Scene implementation for Tiled map management. Extends functionality ActorScene, but in case of MapScene actors are placed on a map. The implementation is based on pyscroll . A tiled map can be created and modified with wonderful Tiled maps editor. The maps loading and usage is backed by PyTMX Actors also can be added to different collision groups, which allows easily identify collision of an actor with a specific actor group","title":"MapScene"},{"location":"api-documentation/#__init___4","text":"| __init__(map: Optional[ScrollMap] = None) Create a MapScene object The map object loading is done with the map loader (a-la pgzero resource loaders). So for loading a map from \u201cdefault.tmx\u201d file of the resource directory: tmx = pgz.maps.default map = pgz.ScrollMap(app.resolution, tmx, [\"Islands\"]) Arguments : map Optional[ScrollMap], optional - Loaded map object. Defaults to None.","title":"__init__"},{"location":"api-documentation/#map","text":"| @property | map() -> ScrollMap Get map object Returns : ScrollMap - the map object used by the scene","title":"map"},{"location":"api-documentation/#set_map","text":"| set_map(map) Set map object Arguments : map [type] - map object to set","title":"set_map"},{"location":"api-documentation/#dispatch_event","text":"| dispatch_event(event: pygame.event.Event) -> None Overriden events dispatch method Used for mouse cursor position transformation into map \u201cworld coordinates\u201d Arguments : event pygame.event.Event - pygame Event object","title":"dispatch_event"},{"location":"api-documentation/#update_4","text":"| update(dt: float) -> None Overriden update method Implementation of the update method for the MapScene. This method updates all the actors attached to the scene. Arguments : dt float - time in milliseconds since the last update","title":"update"},{"location":"api-documentation/#draw_3","text":"| draw(screen: Screen) -> None Overriden rendering method Implementation of the update method for the MapScene. The ActorScene implementation renders all the actorts attached to the scene. Arguments : screen Screen - screen to draw the scene on","title":"draw"},{"location":"api-documentation/#add_actor_1","text":"| add_actor(actor: Actor, central_actor: bool = False, group_name: str = \"\") -> None Overriden add_actor method Implementation of the add_actor method for the MapScene. The ActorScene implementation renders all the actorts attached to the scene. Arguments : actor Actor - actor to add central_actor bool, optional - Sets the actor to be central actor for the scene. The map view will be centered on the actor. Defaults to False. group_name str, optional - Collision group name. Defaults to \u201c\u201d.","title":"add_actor"},{"location":"api-documentation/#remove_actor_1","text":"| remove_actor(actor: Actor) -> None Overriden remove_actor method Implementation of the remove_actor method for the MapScene. Arguments : actor Actor - actor to be removed","title":"remove_actor"},{"location":"api-documentation/#handle_event_2","text":"| handle_event(event: pygame.event.Event) -> None Overriden event handler Implementation of the event handler method for the MapScene. Arguments : event pygame.event.Event - pygame event object","title":"handle_event"},{"location":"api-documentation/#collide_map","text":"| collide_map(actor: Actor) -> bool Detect collision with tiles in the map object used by the scene Arguments : actor Actor - actor for collision detection Returns : bool - True if the collision with map tiles is detected","title":"collide_map"},{"location":"api-documentation/#pgzscenesmenu_scene","text":"","title":"pgz.scenes.menu_scene"},{"location":"api-documentation/#menuscene","text":"class MenuScene(Scene) Base class for a scenes showing menu. MenuScene uses pygame_menu.Menu internally, for the additional information follow the link pygame-menu . Examples : class Menu(pgz.MenuScene): def __init__(self): super().__init__() import pygame_menu self.menu = pygame_menu.Menu(300, 400, \"Welcome\", theme=pygame_menu.themes.THEME_BLUE) self.menu.add_text_input(\"Name :\", textinput_id=\"name\", default=\"John Doe\") self.menu.add_selector('Difficulty :', [('Hard', 1), ('Easy', 2)], onchange=set_difficulty) self.menu.add_button(\"Play\", self.start_the_game) self.menu.add_button(\"Quit\", pygame_menu.events.EXIT) def start_the_game(self): data = self.menu.get_input_data() scene = GameScene() tmx = pgz.maps.default map = pgz.ScrollMap(app.resolution, tmx, [\"Islands\"]) scene.set_map(map) scene.set_client_data({\"name\": data[\"name\"]}) self.change_scene(scene)","title":"MenuScene"},{"location":"api-documentation/#__init___5","text":"| __init__(menu: Optional[pygame_menu.Menu] = None) Create MenuScene Receives a menu object as argument or creates its own menu object. Arguments : menu Optional[pygame_menu.Menu], optional - menu object. Defaults to None.","title":"__init__"},{"location":"api-documentation/#menu","text":"| @property | menu() -> pygame_menu.Menu Get the internal pygame_menu.Menu object. Returns : pygame_menu.Menu - internal menu object.","title":"menu"},{"location":"api-documentation/#draw_4","text":"| draw(screen: Screen) -> None Overriden rendering method Implementation of the update method for the ActorScene. The ActorScene implementation renders all the actorts attached to the scene. Arguments : screen Screen - screen to draw the scene on","title":"draw"},{"location":"api-documentation/#on_exit_2","text":"| on_exit(next_scene: Optional[Scene]) -> None Overriden deinitialization method Arguments : next_scene Optional[Scene] - next scene to run","title":"on_exit"},{"location":"api-documentation/#handle_event_3","text":"| handle_event(event: pygame.event.Event) -> None Overriden event handling method method All of pygame \u2018s events are sent here, so filtering should be applied manually in the subclass. Arguments : event pygame.event.Event - event to handle","title":"handle_event"},{"location":"api-documentation/#pgzscreen","text":"pgz uses the pgzero.screen.Screen implementation for the screen object representation and rendering. More inforamation can be found here .","title":"pgz.screen"},{"location":"api-documentation/#pgzutils","text":"","title":"pgz.utils"},{"location":"api-documentation/#pgzutilscollision_detector","text":"","title":"pgz.utils.collision_detector"},{"location":"api-documentation/#collisiondetector","text":"class CollisionDetector(object) Class helper for easier collision detection The class manages multiple collision groups and can detect a collsion with each one of groups independently.","title":"CollisionDetector"},{"location":"api-documentation/#__init___6","text":"| __init__() -> None Create a collision detecor","title":"__init__"},{"location":"api-documentation/#add_actor_2","text":"| add_actor(actor: Actor, group_name: str = \"\") -> None Add an actor to the detector Arguments : actor Actor - actor to add group_name str, optional - collision group to use. Defaults to \u201c\u201d.","title":"add_actor"},{"location":"api-documentation/#remove_actor_2","text":"| remove_actor(actor: Actor) -> None Remore an actor from the detector and all collision groups Arguments : actor Actor - actor to remove","title":"remove_actor"},{"location":"api-documentation/#get_actor_1","text":"| get_actor(uuid: str) -> Actor Get actor by UUID Arguments : uuid str - UUID of the actor Returns : Actor - actor associated with the UUID","title":"get_actor"},{"location":"api-documentation/#get_actors_1","text":"| get_actors() -> List[Actor] Get list of all the known actors. Returns : List[Actor] - list of actors","title":"get_actors"},{"location":"api-documentation/#collide_group_1","text":"| collide_group(sprite: pygame.sprite.Sprite, group_name: str = \"\") -> Optional[pygame.sprite.Sprite] Detect a collision of an actor with a specified collsion group. Arguments : sprite pygame.sprite.Sprite - actor to use for collision detection. group_name str, optional - collision group name. Defaults to \u201c\u201d. Returns : Optional[pygame.sprite.Sprite] - actor was found in the collsion group.","title":"collide_group"},{"location":"api-documentation/#pgzutilsevent_dispatcher","text":"","title":"pgz.utils.event_dispatcher"},{"location":"api-documentation/#eventdispatcher","text":"class EventDispatcher() Adapt a pgzero game\u2019s raw handler function to take a Pygame Event. Returns a one-argument function of the form handler(event) . This will ensure that the correct arguments are passed to the raw handler based on its argument spec. The wrapped handler will also map certain parameter values using callables from EVENT_PARAM_MAPPERS; this ensures that the value of \u2018button\u2019 inside the handler is a real instance of constants.mouse, which means (among other things) that it will print as a symbolic value rather than a naive integer.","title":"EventDispatcher"},{"location":"api-documentation/#handle_event_4","text":"| handle_event(event: pygame.event.Event) -> None Override me","title":"handle_event"},{"location":"api-documentation/#pgzutilsfps_calc","text":"","title":"pgz.utils.fps_calc"},{"location":"api-documentation/#pgzutilsscroll_map","text":"","title":"pgz.utils.scroll_map"},{"location":"api-documentation/#scrollmap","text":"class ScrollMap(object) Scroll Map object. The implementation is based on pyscroll This class provides functionality: - create and manage a pyscroll group - load a collision layers - manage sprites added to the map - allows to detect collisions with loaded collision layers - render the map and the sprites on top","title":"ScrollMap"},{"location":"api-documentation/#__init___7","text":"| __init__(screen_size: Tuple[int, int], tmx: pytmx.TiledMap, collision_layers: List[str] = []) -> None Create scroll map object. Arguments : screen_size Tuple[int, int] - screen resolution will be used to the map rendering tmx pytmx.TiledMap - loaded pytmx.TiledMap object collision_layers List[str], optional - List of pytmx.TiledMap layer names will be used for tiles collision detection. Defaults to [].","title":"__init__"},{"location":"api-documentation/#add_collision_layers","text":"| add_collision_layers(collision_layers: List[str]) -> None Load pytmx.TiledMap layer tiles for collision detection. Some layer in the pytmx.TiledMap might be be used for collision detection. For example: the layer includes \u201cisland tiles\u201d might be used for collision detection with a \u201cship\u201d actor. Arguments : collision_layers List[str] - List of pytmx.TiledMap layer names will be used for tiles collision detection.","title":"add_collision_layers"},{"location":"api-documentation/#draw_5","text":"| draw(screen: Screen) -> None Draw method similar to the pgz.scene.Scene.draw method. Will draw the map and all actors on top. Arguments : dt float - time in milliseconds since the last update","title":"draw"},{"location":"api-documentation/#update_5","text":"| update(dt: float) -> None Update method similar to the pgz.scene.Scene.update method. All the actors attached to the map will be updated. Arguments : dt float - time in milliseconds since the last update","title":"update"},{"location":"api-documentation/#add_sprite","text":"| add_sprite(sprite: pygame.sprite.Sprite) -> None Add actor/sprite to the map Arguments : sprite pygame.sprite.Sprite - sprite object to add","title":"add_sprite"},{"location":"api-documentation/#remove_sprite","text":"| remove_sprite(sprite: pygame.sprite.Sprite) -> None Remove sprite/actor from the map. Arguments : sprite pygame.sprite.Sprite - sprite object to remove","title":"remove_sprite"},{"location":"api-documentation/#collide_map_1","text":"| collide_map(sprite: pygame.sprite.Sprite) -> bool Detect a collision with tiles on the map Arguments : sprite pygame.sprite.Sprite - sprite/actor for detection Returns : bool - True is the collision with the colision layers was detected","title":"collide_map"}]}