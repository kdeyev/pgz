{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"pgz pgz aim to make development of advanced pygame games easier. pgz uses pgzero as infrastructure intensively, but makes the experience more object oriented. Features More pytonic infrastructure: pgz utilies a lot of features from pgzero Multi-scene games: The idea and some code was taken from EzPyGame Maps, collision detection and maps scrolling: the implementation is based on pyscroll Scenes for rendering Menu based pygame-menu Multi-player game over network: based on simple RPC over WebSockets Installation not yet Documentation More detailed documentation can be found here Quick start pgz heavily uses concepts and some code of EzPyGame and pgzero . pgz game entry point is application, application renders scene, scene can be changed, scene manages actors. So pgz operates by 3 main concepts: Application Scene Actor Application The application and scenes idea was from the EzPyGame . Example of pgz application start: if __name__ == \"__main__\": app = pgz.Application( title=\"pgz Standalone Demo\", resolution=(1280, 720), update_rate=60, ) try: scene = .... app.run(scene) except Exception: # pygame.quit() raise Scene In the snippet above scene object instantiation scene = .... was skipped. The application and scenes idea was from the EzPyGame . Scene is the core of your game, but the active scene of you game can be changed, when you need to change the game behavior. Bassically the pgz.Application delegates all the events processing and rendering logic to the active scene. If the pgz.Application is not require subclassing, the usage of scenes is based on the subclassing idea. There are a few important method to override in pgz.Scene: handle_event(self, event: pygame.event.Event) - for processing pygame events draw(self, screen: pgz.Screen) - for rendering of the scene screen update(self, dt: float) - for modifying the scene state on_enter(self, previous_scene: pgz.Scene) - for initialization of the scene on_exit(self, next_scene: pgz.Scene) - for initialization of the scene class Game(Scene): ... def on_enter(self, previous_scene): self.previous_scene = previous_scene def update(self, dt): self.player.move(dt) if self.player.died(): self.application.change_scene(self.previous_scene) Good news that pgz provides a few pgz.Scene derived scenes for common use cases. So you can subclass from the scene implementation, which is more suitable for your game: pgz.MenuScene - implements game menu rendering as a pgz.Scene subclass pgz.ActorScene - implements the basic actors managements, updates, rendering logic and actors collision detection. pgz.MapScene - extends pgz.ActorScene for games based on the tiled maps. It also implements the tiles collision detection. pgz.RemoteScene - allows to render the view of remote pgz.MapScene or pgz.ActorScene using WebSocket connection. It might be useful handy for building of a multiplayer game Actors Actor concept was inspired from pgzero . Actor is a sprite: alien = Actor('alien') alien.pos = 100, 56 The subclassing from the actor may be a good idea for building of the more complicated logic: class Ship(pgz.Actor): def __init__(self) -> None: super().__init__(random.choice([\"ship (1)\", \"ship (2)\", \"ship (3)\", \"ship (4)\", \"ship (5)\", \"ship (6)\"])) def update(self, dt): self._old_pos = self.pos[:] if self.keyboard.up: self.velocity[1] = -self.speed elif self.keyboard.down: self.velocity[1] = self.speed else: self.velocity[1] = 0 if self.keyboard.left: self.velocity[0] = -self.speed elif self.keyboard.right: self.velocity[0] = self.speed else: self.velocity[0] = 0 self.x += self.velocity[0] * dt self.y += self.velocity[1] * dt def move_back(self, dt): \"\"\"If called after an update, the sprite can move back\"\"\" self.pos = self._old_pos[:] Two important methods for overriding are: def draw(self, screen: Screen) -> None: pass def update(self, dt: float) -> None: pass Once actor is constructed in can be attached to ActorScene and the scene will take care of calling draw and update methods: scene.add_actor(ship) MapScene The usage of pgz.MapScene will require the instantiation of a map object. pgz provides a way for loading and handling Tiled maps. Map loading The map object loading is done with the map loader (a-la pgzero resource loaders). So for loading a map from \"default.tmx\" file of the resource directory: tmx = pgz.maps.default The \"mtx\" files can be created and modified with wonderful Tiled mps editor. Map management and rendering The maps loading and usage is backed by pyscroll pgz provides a pgz.ScrollMap class which covers listed functionality: - create and manage a pyscroll group - load a collision layers - manage sprites added to the map - allows to detect collisions with loaded collision layers - render the map and the sprites on top The code example will load tiled map, instantiate a pgz.ScrollMap object and initialize \"Islands\" layer of the tmx map as a collision layer. tmx = pgz.maps.default map = pgz.ScrollMap(app.resolution, tmx, [\"Islands\"]) Once the map object is initialized it can be used with pgz.MapScene: scene = pgz.MapScene(map) scene.add_actor(ship) ... if scene.collide_map(ship): print(\"I found an island!\") A more complete example of the pgz.MapScene subclassing: class Game(pgz.MapScene): def __init__(self, map): super().__init__(map) self.ship = Ship() # put the ship in the center of the map self.ship.position = self.map.get_center() self.ship.x += 600 self.ship.y += 400 # add our ship to the group self.add_actor(self.ship, central_actor=True) def update(self, dt): self.map.update(dt) if self.map.collide_map(self.ship): self.ship.move_back(dt) def on_mouse_move(self, pos): angle = self.ship.angle_to(pos) + 90 self.ship.angle = angle def on_mouse_down(self, pos, button): ball = CannonBall(self.ship.pos, pos, self.remove_actor) self.add_actor(ball) def on_key_down(self, key): if key == pygame.K_EQUALS: self.map.change_zoom(0.25) elif key == pygame.K_MINUS: self.map.change_zoom(-0.25) Game example The game example which utilizes using all the described concepts, can be fount in demo/demo_standalone.py Multiplayer game with pgz pgz provides two key components for converting your single-player into multiplayer-game over the network: pgz.MultiplayerSceneServer pgz.RemoteScene Multiplayer game server MultiplayerSceneServer opens a WebSocket server and instantiate a pgz.Scene per connected player(client): tmx = pgz.maps.default map = pgz.ScrollMap((1280, 720), tmx, [\"Islands\"]) # Build and start game server self.server = pgz.MultiplayerSceneServer(map, GameScene) self.server.start_server(port=self.port) All the scenes will share the map object and collision detector object. So, the communication between different players scenes is done with collision detection. If one scene shoots the cannon ball (by implementing the CannonBall actor and adding its instance to the map): def on_mouse_down(self, pos, button): start_point = self.calc_cannon_ball_start_pos(pos) if start_point: ball = CannonBall(pos=start_point, target=pos) self.add_actor(ball, group_name=\"cannon_balls\") Another player(scene) might be harmed by the cannon ball using the collision detection: def update(self, dt): super().update(dt) cannon_ball = self.collide_group(self.ship, \"cannon_balls\") if cannon_ball: # pgz.sounds.arrr.play() self.ship.health -= cannon_ball.hit_rate * dt Multiplayer game client pgz.RemoteScene allows to communicate with pgz.MultiplayerSceneServer and render the remote scene locally: data = self.menu.get_input_data() server_url = data[\"server_url\"] tmx = pgz.maps.default map = pgz.ScrollMap(app.resolution, tmx, [\"Islands\"]) game = pgz.RemoteScene(map, server_url, client_data={\"name\": data[\"name\"]}) Pay attention that client process needs to have access to the same external resources (like map files, images,...) as the game server. Multiplayer game example The multiplayer game example can be found in demo/demo_server.py and demo/demo_client.py Demo","title":"Home"},{"location":"#pgz","text":"pgz aim to make development of advanced pygame games easier. pgz uses pgzero as infrastructure intensively, but makes the experience more object oriented.","title":"pgz"},{"location":"#features","text":"More pytonic infrastructure: pgz utilies a lot of features from pgzero Multi-scene games: The idea and some code was taken from EzPyGame Maps, collision detection and maps scrolling: the implementation is based on pyscroll Scenes for rendering Menu based pygame-menu Multi-player game over network: based on simple RPC over WebSockets","title":"Features"},{"location":"#installation","text":"not yet","title":"Installation"},{"location":"#documentation","text":"More detailed documentation can be found here","title":"Documentation"},{"location":"#quick-start","text":"pgz heavily uses concepts and some code of EzPyGame and pgzero . pgz game entry point is application, application renders scene, scene can be changed, scene manages actors. So pgz operates by 3 main concepts: Application Scene Actor","title":"Quick start"},{"location":"#application","text":"The application and scenes idea was from the EzPyGame . Example of pgz application start: if __name__ == \"__main__\": app = pgz.Application( title=\"pgz Standalone Demo\", resolution=(1280, 720), update_rate=60, ) try: scene = .... app.run(scene) except Exception: # pygame.quit() raise","title":"Application"},{"location":"#scene","text":"In the snippet above scene object instantiation scene = .... was skipped. The application and scenes idea was from the EzPyGame . Scene is the core of your game, but the active scene of you game can be changed, when you need to change the game behavior. Bassically the pgz.Application delegates all the events processing and rendering logic to the active scene. If the pgz.Application is not require subclassing, the usage of scenes is based on the subclassing idea. There are a few important method to override in pgz.Scene: handle_event(self, event: pygame.event.Event) - for processing pygame events draw(self, screen: pgz.Screen) - for rendering of the scene screen update(self, dt: float) - for modifying the scene state on_enter(self, previous_scene: pgz.Scene) - for initialization of the scene on_exit(self, next_scene: pgz.Scene) - for initialization of the scene class Game(Scene): ... def on_enter(self, previous_scene): self.previous_scene = previous_scene def update(self, dt): self.player.move(dt) if self.player.died(): self.application.change_scene(self.previous_scene) Good news that pgz provides a few pgz.Scene derived scenes for common use cases. So you can subclass from the scene implementation, which is more suitable for your game: pgz.MenuScene - implements game menu rendering as a pgz.Scene subclass pgz.ActorScene - implements the basic actors managements, updates, rendering logic and actors collision detection. pgz.MapScene - extends pgz.ActorScene for games based on the tiled maps. It also implements the tiles collision detection. pgz.RemoteScene - allows to render the view of remote pgz.MapScene or pgz.ActorScene using WebSocket connection. It might be useful handy for building of a multiplayer game","title":"Scene"},{"location":"#actors","text":"Actor concept was inspired from pgzero . Actor is a sprite: alien = Actor('alien') alien.pos = 100, 56 The subclassing from the actor may be a good idea for building of the more complicated logic: class Ship(pgz.Actor): def __init__(self) -> None: super().__init__(random.choice([\"ship (1)\", \"ship (2)\", \"ship (3)\", \"ship (4)\", \"ship (5)\", \"ship (6)\"])) def update(self, dt): self._old_pos = self.pos[:] if self.keyboard.up: self.velocity[1] = -self.speed elif self.keyboard.down: self.velocity[1] = self.speed else: self.velocity[1] = 0 if self.keyboard.left: self.velocity[0] = -self.speed elif self.keyboard.right: self.velocity[0] = self.speed else: self.velocity[0] = 0 self.x += self.velocity[0] * dt self.y += self.velocity[1] * dt def move_back(self, dt): \"\"\"If called after an update, the sprite can move back\"\"\" self.pos = self._old_pos[:] Two important methods for overriding are: def draw(self, screen: Screen) -> None: pass def update(self, dt: float) -> None: pass Once actor is constructed in can be attached to ActorScene and the scene will take care of calling draw and update methods: scene.add_actor(ship)","title":"Actors"},{"location":"#mapscene","text":"The usage of pgz.MapScene will require the instantiation of a map object. pgz provides a way for loading and handling Tiled maps.","title":"MapScene"},{"location":"#map-loading","text":"The map object loading is done with the map loader (a-la pgzero resource loaders). So for loading a map from \"default.tmx\" file of the resource directory: tmx = pgz.maps.default The \"mtx\" files can be created and modified with wonderful Tiled mps editor.","title":"Map loading"},{"location":"#map-management-and-rendering","text":"The maps loading and usage is backed by pyscroll pgz provides a pgz.ScrollMap class which covers listed functionality: - create and manage a pyscroll group - load a collision layers - manage sprites added to the map - allows to detect collisions with loaded collision layers - render the map and the sprites on top The code example will load tiled map, instantiate a pgz.ScrollMap object and initialize \"Islands\" layer of the tmx map as a collision layer. tmx = pgz.maps.default map = pgz.ScrollMap(app.resolution, tmx, [\"Islands\"]) Once the map object is initialized it can be used with pgz.MapScene: scene = pgz.MapScene(map) scene.add_actor(ship) ... if scene.collide_map(ship): print(\"I found an island!\") A more complete example of the pgz.MapScene subclassing: class Game(pgz.MapScene): def __init__(self, map): super().__init__(map) self.ship = Ship() # put the ship in the center of the map self.ship.position = self.map.get_center() self.ship.x += 600 self.ship.y += 400 # add our ship to the group self.add_actor(self.ship, central_actor=True) def update(self, dt): self.map.update(dt) if self.map.collide_map(self.ship): self.ship.move_back(dt) def on_mouse_move(self, pos): angle = self.ship.angle_to(pos) + 90 self.ship.angle = angle def on_mouse_down(self, pos, button): ball = CannonBall(self.ship.pos, pos, self.remove_actor) self.add_actor(ball) def on_key_down(self, key): if key == pygame.K_EQUALS: self.map.change_zoom(0.25) elif key == pygame.K_MINUS: self.map.change_zoom(-0.25)","title":"Map management and rendering"},{"location":"#game-example","text":"The game example which utilizes using all the described concepts, can be fount in demo/demo_standalone.py","title":"Game example"},{"location":"#multiplayer-game-with-pgz","text":"pgz provides two key components for converting your single-player into multiplayer-game over the network: pgz.MultiplayerSceneServer pgz.RemoteScene","title":"Multiplayer game with pgz"},{"location":"#multiplayer-game-server","text":"MultiplayerSceneServer opens a WebSocket server and instantiate a pgz.Scene per connected player(client): tmx = pgz.maps.default map = pgz.ScrollMap((1280, 720), tmx, [\"Islands\"]) # Build and start game server self.server = pgz.MultiplayerSceneServer(map, GameScene) self.server.start_server(port=self.port) All the scenes will share the map object and collision detector object. So, the communication between different players scenes is done with collision detection. If one scene shoots the cannon ball (by implementing the CannonBall actor and adding its instance to the map): def on_mouse_down(self, pos, button): start_point = self.calc_cannon_ball_start_pos(pos) if start_point: ball = CannonBall(pos=start_point, target=pos) self.add_actor(ball, group_name=\"cannon_balls\") Another player(scene) might be harmed by the cannon ball using the collision detection: def update(self, dt): super().update(dt) cannon_ball = self.collide_group(self.ship, \"cannon_balls\") if cannon_ball: # pgz.sounds.arrr.play() self.ship.health -= cannon_ball.hit_rate * dt","title":"Multiplayer game server"},{"location":"#multiplayer-game-client","text":"pgz.RemoteScene allows to communicate with pgz.MultiplayerSceneServer and render the remote scene locally: data = self.menu.get_input_data() server_url = data[\"server_url\"] tmx = pgz.maps.default map = pgz.ScrollMap(app.resolution, tmx, [\"Islands\"]) game = pgz.RemoteScene(map, server_url, client_data={\"name\": data[\"name\"]}) Pay attention that client process needs to have access to the same external resources (like map files, images,...) as the game server.","title":"Multiplayer game client"},{"location":"#multiplayer-game-example","text":"The multiplayer game example can be found in demo/demo_server.py and demo/demo_client.py","title":"Multiplayer game example"},{"location":"#demo","text":"","title":"Demo"},{"location":"api-documentation/","text":"pgz pgz.actor pgz.application Application Objects class Application() The idea and the original code was taken from EzPyGame: https://github.com/Mahi/EzPyGame A simple wrapper around :mod: pygame for running games easily. Also makes scene management seamless together with the :class: .Scene class. :param str|None title: title to display in the window's title bar :param tuple[int,int]|None resolution: resolution of the game window :param int|None update_rate: how many times per second to update If any parameters are left to None , these settings must be defined either manually through application.<setting> = value or via :class: .Scene 's class variable settings. Example usage: .. code-block:: python class Menu(pgz.Scene): ... class Game(pgz.Scene): ... app = pgz.Application( title='My First Application', resolution=(1280, 720), update_rate=60, ) main_menu = Menu() app.run(main_menu) active_scene | @property | active_scene() -> Optional[Scene] The currently active scene. Can be None . change_scene | change_scene(scene: Optional[Scene]) -> None Change the currently active scene. This will invoke :meth: .Scene.on_exit and :meth: .Scene.on_enter methods on the switching scenes. If None is provided, the application's execution will end. :param Scene|None scene: the scene to change into run | run(scene: Optional[Scene] = None) -> None Execute the application. :param scene.Scene|None scene: scene to start the execution from mainloop | async mainloop() -> None Run the main loop of Pygame Zero. pgz.clock pgz.keyboard Keyboard Objects class Keyboard() The current state of the keyboard. Each attribute represents a key. For example, :: keyboard.a is True if the 'A' key is depressed, and False otherwise. pgz.loaders pgz.multiplayer_scene pgz.rect pgz.scene Scene Objects class Scene(EventDispatcher) The idea and the original code was taken from EzPyGame: https://github.com/Mahi/EzPyGame An isolated scene which can be ran by an application. Create your own scene by subclassing and overriding any methods. The hosting :class: .Application instance is accessible through the :attr: application property. Example usage with two scenes interacting: .. code-block:: python class Menu(Scene): def __init__(self): self.font = pygame.font.Font(...) def on_enter(self, previous_scene): self.application.title = 'Main Menu' self.application.resolution = (640, 480) self.application.update_rate = 30 def draw(self, screen): pygame.draw.rect(...) text = self.font.render(...) screen.blit(text, ...) def handle_event(self, event): if event.type == pygame.MOUSEBUTTONUP: if event.button == 1: game_size = self._get_game_size(event.pos) self.change_scene(Game(game_size)) def _get_game_size(self, mouse_pos_upon_click): ... class Game(ezpygame.Scene): title = 'The Game!' resolution = (1280, 720) update_rate = 60 def __init__(self, size): super().__init__() self.size = size self.player = ... ... def on_enter(self, previous_scene): super().on_enter(previous_scene) self.previous_scene = previous_scene def draw(self, screen): self.player.draw(screen) for enemy in self.enemies: ... def update(self, dt): self.player.move(dt) ... if self.player.is_dead(): self.application.change_scene(self.previous_scene) elif self.player_won(): self.application.change_scene(...) def handle_event(self, event): ... # Player movement etc. The above two classes use different approaches for changing the application's settings when the scene is entered: Manually set them in :meth: on_enter , as seen in Menu Use class variables, as I did with Game When using class variables (2), you can leave out any setting (defaults to None ) to not override that particular setting. If you override :meth: on_enter in the subclass, you must call super().on_enter(previous_scene) to use the class variables. These settings can further be overridden in individual instances: my_scene0 = MyScene() my_scene0.resolution = (1280, 720) my_scene1 = MyScene(title='My Second Awesome Scene') Shotcuts for simpler event handling: def on_mouse_up(self, pos, button): # Override this for easier events handling. pass def on_mouse_down(self, pos, button): # Override this for easier events handling. pass def on_mouse_move(self, pos): # Override this for easier events handling. pass def on_key_down(self, key): # Override this for easier events handling. pass def on_key_up(self, key): # Override this for easier events handling. pass scene_uuid | @property | scene_uuid() -> str Get scene UUID. client_data | @property | client_data() -> Dict[str, Any] Get data provided by cleint side. clock | @property | clock() -> Clock Clock object. Actually returns the global clock object. keyboard | @property | keyboard() -> Keyboard Clock object. Actually returns the global clock object. draw | draw(screen: Screen) -> None Override this with the scene drawing. :param pgz.screen.Screen screen: screen to draw the scene on update | update(dt: float) -> None Override this with the scene update tick. :param int dt: time in milliseconds since the last update handle_event | handle_event(event: pygame.event.Event) -> None Override this to handle an event in the scene. All of :mod: pygame 's events are sent here, so filtering should be applied manually in the subclass. :param pygame.event.Event event: event to handle on_enter | on_enter(previous_scene: Optional[\"Scene\"]) -> None Override this to initialize upon scene entering. The :attr: application property is initialized at this point, so you are free to access it through self.application . Stuff like changing resolution etc. should be done here. If you override this method and want to use class variables to change the application's settings, you must call super().on_enter(previous_scene) in the subclass. :param Scene|None previous_scene: previous scene to run on_exit | on_exit(next_scene: Optional[\"Scene\"]) -> None Override this to deinitialize upon scene exiting. The :attr: application property is still initialized at this point. Feel free to do saving, settings reset, etc. here. :param Scene|None next_scene: next scene to run pgz.scenes pgz.scenes.actor_scene ActorScene Objects class ActorScene(Scene) Scene implementation for management of multiple actors. Actors also can be added to different collision groups, which allows easily identify collision of an actor with a specific actor group. __init__ | __init__() -> None Create an ActorScene object set_collision_detector | set_collision_detector(collision_detector: CollisionDetector) Set external collsinion detector object. The default collision detector can be use in the most of the cases. This method in used by multiplayer. add_actor | add_actor(actor: Actor, group_name: str = \"\") -> None Add actor to the scene and add the actor to the collision group. Arguments : actor Actor - actor to add group_name str, optional - Collision group name. Defaults to \"\". remove_actor | remove_actor(actor: Actor) -> None Remove actor from the scene. Actor also will be removed from the associated collision detector Arguments : actor Actor - Actor to be removed remove_actors | remove_actors() -> None Remove all actors from the scene and the associated collision detector get_actor | get_actor(uuid: str) -> Actor Get actor object by its UUID Arguments : uuid str - UUID of the actor to be retrieved Returns : Actor - Actor associated with the UUID get_actors | get_actors() -> List[Actor] Get list of actors Returns : List[Actor] - The list of actors on the scene collide_group | collide_group(actor: Actor, group_name: str = \"\") -> Optional[Actor] Detect collision of a ginen actor with the actors in requested collsion group. Arguments : actor Actor - actor to detect collisions with group_name str, optional - Collision group name. Defaults to \"\". Returns : Optional[Actor] - A collins actor in the specified collision group draw | draw(surface: Screen) -> None Overriden rendering method Implementation of the update method for the ActorScene. The ActorScene implementation renders all the actorts attached to the scene. :param pgz.screen.Screen screen: screen to draw the scene on update | update(dt: float) -> None Overriden update method Implementation of the update method for the ActorScene. This method updates all the actors attached to the scene. :param int dt: time in milliseconds since the last update pgz.scenes.map_scene MapScene Objects class MapScene(ActorScene) Scene implementation for Tiled map management. Extends functionality ActorScene, but in case of MapScene actors are placed on a map. The implementation is based on pyscroll . A tiled map can be created and modified with wonderful Tiled maps editor. The maps loading and usage is backed by PyTMX Actors also can be added to different collision groups, which allows easily identify collision of an actor with a specific actor group __init__ | __init__(map: Optional[ScrollMap] = None) Create a MapScene object The map object loading is done with the map loader (a-la pgzero resource loaders). So for loading a map from \"default.tmx\" file of the resource directory: tmx = pgz.maps.default map = pgz.ScrollMap(app.resolution, tmx, [\"Islands\"]) Arguments : map Optional[ScrollMap], optional - Loaded map object. Defaults to None. map | @property | map() -> ScrollMap Get map object Returns : ScrollMap - the map object used by the scene set_map | set_map(map) Set map object Arguments : map [type] - map object to set dispatch_event | dispatch_event(event: pygame.event.Event) -> None Overriden events dispatch method Used for mouse cursor position transformation into map \"world coordinates\" Arguments : event pygame.event.Event - pygame Event object update | update(dt: float) -> None Overriden update method Implementation of the update method for the MapScene. This method updates all the actors attached to the scene. Arguments : dt float - time in milliseconds since the last update draw | draw(screen: Screen) -> None Overriden rendering method Implementation of the update method for the MapScene. The ActorScene implementation renders all the actorts attached to the scene. Arguments : screen Screen - screen to draw the scene on add_actor | add_actor(actor: Actor, central_actor: bool = False, group_name: str = \"\") -> None Overriden add_actor method Implementation of the add_actor method for the MapScene. The ActorScene implementation renders all the actorts attached to the scene. Arguments : actor Actor - actor to add central_actor bool, optional - Sets the actor to be central actor for the scene. The map view will be centered on the actor. Defaults to False. group_name str, optional - Collision group name. Defaults to \"\". remove_actor | remove_actor(actor: Actor) -> None Overriden remove_actor method Implementation of the remove_actor method for the MapScene. Arguments : actor Actor - actor to be removed handle_event | handle_event(event: pygame.event.Event) -> None Overriden event handler Implementation of the event handler method for the MapScene. Arguments : event pygame.event.Event - pygame event object collide_map | collide_map(actor: Actor) -> bool Detect collision with tiles in the map object used by the scene Arguments : actor Actor - actor for collision detection Returns : bool - True if the collision with map tiles is detected pgz.scenes.menu_scene pgz.screen","title":"API Documentation"},{"location":"api-documentation/#pgz","text":"","title":"pgz"},{"location":"api-documentation/#pgzactor","text":"","title":"pgz.actor"},{"location":"api-documentation/#pgzapplication","text":"","title":"pgz.application"},{"location":"api-documentation/#application-objects","text":"class Application() The idea and the original code was taken from EzPyGame: https://github.com/Mahi/EzPyGame A simple wrapper around :mod: pygame for running games easily. Also makes scene management seamless together with the :class: .Scene class. :param str|None title: title to display in the window's title bar :param tuple[int,int]|None resolution: resolution of the game window :param int|None update_rate: how many times per second to update If any parameters are left to None , these settings must be defined either manually through application.<setting> = value or via :class: .Scene 's class variable settings. Example usage: .. code-block:: python class Menu(pgz.Scene): ... class Game(pgz.Scene): ... app = pgz.Application( title='My First Application', resolution=(1280, 720), update_rate=60, ) main_menu = Menu() app.run(main_menu)","title":"Application Objects"},{"location":"api-documentation/#active_scene","text":"| @property | active_scene() -> Optional[Scene] The currently active scene. Can be None .","title":"active_scene"},{"location":"api-documentation/#change_scene","text":"| change_scene(scene: Optional[Scene]) -> None Change the currently active scene. This will invoke :meth: .Scene.on_exit and :meth: .Scene.on_enter methods on the switching scenes. If None is provided, the application's execution will end. :param Scene|None scene: the scene to change into","title":"change_scene"},{"location":"api-documentation/#run","text":"| run(scene: Optional[Scene] = None) -> None Execute the application. :param scene.Scene|None scene: scene to start the execution from","title":"run"},{"location":"api-documentation/#mainloop","text":"| async mainloop() -> None Run the main loop of Pygame Zero.","title":"mainloop"},{"location":"api-documentation/#pgzclock","text":"","title":"pgz.clock"},{"location":"api-documentation/#pgzkeyboard","text":"","title":"pgz.keyboard"},{"location":"api-documentation/#keyboard-objects","text":"class Keyboard() The current state of the keyboard. Each attribute represents a key. For example, :: keyboard.a is True if the 'A' key is depressed, and False otherwise.","title":"Keyboard Objects"},{"location":"api-documentation/#pgzloaders","text":"","title":"pgz.loaders"},{"location":"api-documentation/#pgzmultiplayer_scene","text":"","title":"pgz.multiplayer_scene"},{"location":"api-documentation/#pgzrect","text":"","title":"pgz.rect"},{"location":"api-documentation/#pgzscene","text":"","title":"pgz.scene"},{"location":"api-documentation/#scene-objects","text":"class Scene(EventDispatcher) The idea and the original code was taken from EzPyGame: https://github.com/Mahi/EzPyGame An isolated scene which can be ran by an application. Create your own scene by subclassing and overriding any methods. The hosting :class: .Application instance is accessible through the :attr: application property. Example usage with two scenes interacting: .. code-block:: python class Menu(Scene): def __init__(self): self.font = pygame.font.Font(...) def on_enter(self, previous_scene): self.application.title = 'Main Menu' self.application.resolution = (640, 480) self.application.update_rate = 30 def draw(self, screen): pygame.draw.rect(...) text = self.font.render(...) screen.blit(text, ...) def handle_event(self, event): if event.type == pygame.MOUSEBUTTONUP: if event.button == 1: game_size = self._get_game_size(event.pos) self.change_scene(Game(game_size)) def _get_game_size(self, mouse_pos_upon_click): ... class Game(ezpygame.Scene): title = 'The Game!' resolution = (1280, 720) update_rate = 60 def __init__(self, size): super().__init__() self.size = size self.player = ... ... def on_enter(self, previous_scene): super().on_enter(previous_scene) self.previous_scene = previous_scene def draw(self, screen): self.player.draw(screen) for enemy in self.enemies: ... def update(self, dt): self.player.move(dt) ... if self.player.is_dead(): self.application.change_scene(self.previous_scene) elif self.player_won(): self.application.change_scene(...) def handle_event(self, event): ... # Player movement etc. The above two classes use different approaches for changing the application's settings when the scene is entered: Manually set them in :meth: on_enter , as seen in Menu Use class variables, as I did with Game When using class variables (2), you can leave out any setting (defaults to None ) to not override that particular setting. If you override :meth: on_enter in the subclass, you must call super().on_enter(previous_scene) to use the class variables. These settings can further be overridden in individual instances: my_scene0 = MyScene() my_scene0.resolution = (1280, 720) my_scene1 = MyScene(title='My Second Awesome Scene') Shotcuts for simpler event handling: def on_mouse_up(self, pos, button): # Override this for easier events handling. pass def on_mouse_down(self, pos, button): # Override this for easier events handling. pass def on_mouse_move(self, pos): # Override this for easier events handling. pass def on_key_down(self, key): # Override this for easier events handling. pass def on_key_up(self, key): # Override this for easier events handling. pass","title":"Scene Objects"},{"location":"api-documentation/#scene_uuid","text":"| @property | scene_uuid() -> str Get scene UUID.","title":"scene_uuid"},{"location":"api-documentation/#client_data","text":"| @property | client_data() -> Dict[str, Any] Get data provided by cleint side.","title":"client_data"},{"location":"api-documentation/#clock","text":"| @property | clock() -> Clock Clock object. Actually returns the global clock object.","title":"clock"},{"location":"api-documentation/#keyboard","text":"| @property | keyboard() -> Keyboard Clock object. Actually returns the global clock object.","title":"keyboard"},{"location":"api-documentation/#draw","text":"| draw(screen: Screen) -> None Override this with the scene drawing. :param pgz.screen.Screen screen: screen to draw the scene on","title":"draw"},{"location":"api-documentation/#update","text":"| update(dt: float) -> None Override this with the scene update tick. :param int dt: time in milliseconds since the last update","title":"update"},{"location":"api-documentation/#handle_event","text":"| handle_event(event: pygame.event.Event) -> None Override this to handle an event in the scene. All of :mod: pygame 's events are sent here, so filtering should be applied manually in the subclass. :param pygame.event.Event event: event to handle","title":"handle_event"},{"location":"api-documentation/#on_enter","text":"| on_enter(previous_scene: Optional[\"Scene\"]) -> None Override this to initialize upon scene entering. The :attr: application property is initialized at this point, so you are free to access it through self.application . Stuff like changing resolution etc. should be done here. If you override this method and want to use class variables to change the application's settings, you must call super().on_enter(previous_scene) in the subclass. :param Scene|None previous_scene: previous scene to run","title":"on_enter"},{"location":"api-documentation/#on_exit","text":"| on_exit(next_scene: Optional[\"Scene\"]) -> None Override this to deinitialize upon scene exiting. The :attr: application property is still initialized at this point. Feel free to do saving, settings reset, etc. here. :param Scene|None next_scene: next scene to run","title":"on_exit"},{"location":"api-documentation/#pgzscenes","text":"","title":"pgz.scenes"},{"location":"api-documentation/#pgzscenesactor_scene","text":"","title":"pgz.scenes.actor_scene"},{"location":"api-documentation/#actorscene-objects","text":"class ActorScene(Scene) Scene implementation for management of multiple actors. Actors also can be added to different collision groups, which allows easily identify collision of an actor with a specific actor group.","title":"ActorScene Objects"},{"location":"api-documentation/#__init__","text":"| __init__() -> None Create an ActorScene object","title":"__init__"},{"location":"api-documentation/#set_collision_detector","text":"| set_collision_detector(collision_detector: CollisionDetector) Set external collsinion detector object. The default collision detector can be use in the most of the cases. This method in used by multiplayer.","title":"set_collision_detector"},{"location":"api-documentation/#add_actor","text":"| add_actor(actor: Actor, group_name: str = \"\") -> None Add actor to the scene and add the actor to the collision group. Arguments : actor Actor - actor to add group_name str, optional - Collision group name. Defaults to \"\".","title":"add_actor"},{"location":"api-documentation/#remove_actor","text":"| remove_actor(actor: Actor) -> None Remove actor from the scene. Actor also will be removed from the associated collision detector Arguments : actor Actor - Actor to be removed","title":"remove_actor"},{"location":"api-documentation/#remove_actors","text":"| remove_actors() -> None Remove all actors from the scene and the associated collision detector","title":"remove_actors"},{"location":"api-documentation/#get_actor","text":"| get_actor(uuid: str) -> Actor Get actor object by its UUID Arguments : uuid str - UUID of the actor to be retrieved Returns : Actor - Actor associated with the UUID","title":"get_actor"},{"location":"api-documentation/#get_actors","text":"| get_actors() -> List[Actor] Get list of actors Returns : List[Actor] - The list of actors on the scene","title":"get_actors"},{"location":"api-documentation/#collide_group","text":"| collide_group(actor: Actor, group_name: str = \"\") -> Optional[Actor] Detect collision of a ginen actor with the actors in requested collsion group. Arguments : actor Actor - actor to detect collisions with group_name str, optional - Collision group name. Defaults to \"\". Returns : Optional[Actor] - A collins actor in the specified collision group","title":"collide_group"},{"location":"api-documentation/#draw_1","text":"| draw(surface: Screen) -> None Overriden rendering method Implementation of the update method for the ActorScene. The ActorScene implementation renders all the actorts attached to the scene. :param pgz.screen.Screen screen: screen to draw the scene on","title":"draw"},{"location":"api-documentation/#update_1","text":"| update(dt: float) -> None Overriden update method Implementation of the update method for the ActorScene. This method updates all the actors attached to the scene. :param int dt: time in milliseconds since the last update","title":"update"},{"location":"api-documentation/#pgzscenesmap_scene","text":"","title":"pgz.scenes.map_scene"},{"location":"api-documentation/#mapscene-objects","text":"class MapScene(ActorScene) Scene implementation for Tiled map management. Extends functionality ActorScene, but in case of MapScene actors are placed on a map. The implementation is based on pyscroll . A tiled map can be created and modified with wonderful Tiled maps editor. The maps loading and usage is backed by PyTMX Actors also can be added to different collision groups, which allows easily identify collision of an actor with a specific actor group","title":"MapScene Objects"},{"location":"api-documentation/#__init___1","text":"| __init__(map: Optional[ScrollMap] = None) Create a MapScene object The map object loading is done with the map loader (a-la pgzero resource loaders). So for loading a map from \"default.tmx\" file of the resource directory: tmx = pgz.maps.default map = pgz.ScrollMap(app.resolution, tmx, [\"Islands\"]) Arguments : map Optional[ScrollMap], optional - Loaded map object. Defaults to None.","title":"__init__"},{"location":"api-documentation/#map","text":"| @property | map() -> ScrollMap Get map object Returns : ScrollMap - the map object used by the scene","title":"map"},{"location":"api-documentation/#set_map","text":"| set_map(map) Set map object Arguments : map [type] - map object to set","title":"set_map"},{"location":"api-documentation/#dispatch_event","text":"| dispatch_event(event: pygame.event.Event) -> None Overriden events dispatch method Used for mouse cursor position transformation into map \"world coordinates\" Arguments : event pygame.event.Event - pygame Event object","title":"dispatch_event"},{"location":"api-documentation/#update_2","text":"| update(dt: float) -> None Overriden update method Implementation of the update method for the MapScene. This method updates all the actors attached to the scene. Arguments : dt float - time in milliseconds since the last update","title":"update"},{"location":"api-documentation/#draw_2","text":"| draw(screen: Screen) -> None Overriden rendering method Implementation of the update method for the MapScene. The ActorScene implementation renders all the actorts attached to the scene. Arguments : screen Screen - screen to draw the scene on","title":"draw"},{"location":"api-documentation/#add_actor_1","text":"| add_actor(actor: Actor, central_actor: bool = False, group_name: str = \"\") -> None Overriden add_actor method Implementation of the add_actor method for the MapScene. The ActorScene implementation renders all the actorts attached to the scene. Arguments : actor Actor - actor to add central_actor bool, optional - Sets the actor to be central actor for the scene. The map view will be centered on the actor. Defaults to False. group_name str, optional - Collision group name. Defaults to \"\".","title":"add_actor"},{"location":"api-documentation/#remove_actor_1","text":"| remove_actor(actor: Actor) -> None Overriden remove_actor method Implementation of the remove_actor method for the MapScene. Arguments : actor Actor - actor to be removed","title":"remove_actor"},{"location":"api-documentation/#handle_event_1","text":"| handle_event(event: pygame.event.Event) -> None Overriden event handler Implementation of the event handler method for the MapScene. Arguments : event pygame.event.Event - pygame event object","title":"handle_event"},{"location":"api-documentation/#collide_map","text":"| collide_map(actor: Actor) -> bool Detect collision with tiles in the map object used by the scene Arguments : actor Actor - actor for collision detection Returns : bool - True if the collision with map tiles is detected","title":"collide_map"},{"location":"api-documentation/#pgzscenesmenu_scene","text":"","title":"pgz.scenes.menu_scene"},{"location":"api-documentation/#pgzscreen","text":"","title":"pgz.screen"}]}