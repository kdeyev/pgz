<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../img/favicon.ico">
        <title>API Documentation - pgz</title>
        <link href="../css/bootstrap.min.css" rel="stylesheet">
        <link href="../css/font-awesome.min.css" rel="stylesheet">
        <link href="../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">

        <script src="../js/jquery-1.10.2.min.js" defer></script>
        <script src="../js/bootstrap.min.js" defer></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
        <script>hljs.initHighlightingOnLoad();</script> 
    </head>

    <body>
        <div class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary">
            <div class="container">
                <a class="navbar-brand" href="..">pgz</a>
                <!-- Expander button -->
                <button type="button" class="navbar-toggler" data-toggle="collapse" data-target="#navbar-collapse">
                    <span class="navbar-toggler-icon"></span>
                </button>

                <!-- Expanded navigation -->
                <div id="navbar-collapse" class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li class="navitem">
                                <a href=".." class="nav-link">Home</a>
                            </li>
                            <li class="navitem active">
                                <a href="./" class="nav-link">API Documentation</a>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav ml-auto">
                        <li class="nav-item">
                            <a href="#" class="nav-link" data-toggle="modal" data-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                            <li class="nav-item">
                                <a rel="prev" href=".." class="nav-link">
                                    <i class="fa fa-arrow-left"></i> Previous
                                </a>
                            </li>
                            <li class="nav-item">
                                <a rel="next" class="nav-link disabled">
                                    Next <i class="fa fa-arrow-right"></i>
                                </a>
                            </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
            <div class="row">
                    <div class="col-md-3"><div class="navbar-light navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-toggle="collapse" data-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-secondary">
        <ul class="nav flex-column">
            
            <li class="nav-item" data-level="1"><a href="#pgz" class="nav-link">pgz</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            
            <li class="nav-item" data-level="1"><a href="#pgzactor" class="nav-link">pgz.actor</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            
            <li class="nav-item" data-level="1"><a href="#pgzapplication" class="nav-link">pgz.application</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#application" class="nav-link">Application</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-level="1"><a href="#pgzclock" class="nav-link">pgz.clock</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            
            <li class="nav-item" data-level="1"><a href="#pgzkeyboard" class="nav-link">pgz.keyboard</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#keyboard_1" class="nav-link">Keyboard</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-level="1"><a href="#pgzloaders" class="nav-link">pgz.loaders</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            
            <li class="nav-item" data-level="1"><a href="#pgzmultiplayer" class="nav-link">pgz.multiplayer</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            
            <li class="nav-item" data-level="1"><a href="#pgzmultiplayermultiplayer_scene" class="nav-link">pgz.multiplayer.multiplayer_scene</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#multiplayersceneserver" class="nav-link">MultiplayerSceneServer</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#remotesceneclient" class="nav-link">RemoteSceneClient</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-level="1"><a href="#pgzmultiplayerrpc" class="nav-link">pgz.multiplayer.rpc</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            
            <li class="nav-item" data-level="1"><a href="#pgzmultiplayerscreen_rpc" class="nav-link">pgz.multiplayer.screen_rpc</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#rpcsurfacepainter" class="nav-link">RPCSurfacePainter</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#rpcscreenserver" class="nav-link">RPCScreenServer</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-level="1"><a href="#pgzrect" class="nav-link">pgz.rect</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            
            <li class="nav-item" data-level="1"><a href="#pgzscene" class="nav-link">pgz.scene</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#scene" class="nav-link">Scene</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-level="1"><a href="#pgzscenes" class="nav-link">pgz.scenes</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            
            <li class="nav-item" data-level="1"><a href="#pgzscenesactor_scene" class="nav-link">pgz.scenes.actor_scene</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#actorscene" class="nav-link">ActorScene</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-level="1"><a href="#pgzscenesmap_scene" class="nav-link">pgz.scenes.map_scene</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#mapscene" class="nav-link">MapScene</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-level="1"><a href="#pgzscenesmenu_scene" class="nav-link">pgz.scenes.menu_scene</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#menuscene" class="nav-link">MenuScene</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-level="1"><a href="#pgzscreen" class="nav-link">pgz.screen</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            
            <li class="nav-item" data-level="1"><a href="#pgzutils" class="nav-link">pgz.utils</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            
            <li class="nav-item" data-level="1"><a href="#pgzutilscollision_detector" class="nav-link">pgz.utils.collision_detector</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#collisiondetector" class="nav-link">CollisionDetector</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-level="1"><a href="#pgzutilsevent_dispatcher" class="nav-link">pgz.utils.event_dispatcher</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#eventdispatcher" class="nav-link">EventDispatcher</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-level="1"><a href="#pgzutilsfps_calc" class="nav-link">pgz.utils.fps_calc</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            
            <li class="nav-item" data-level="1"><a href="#pgzutilsscroll_map" class="nav-link">pgz.utils.scroll_map</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#scrollmap" class="nav-link">ScrollMap</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
        </ul>
    </div>
</div></div>
                    <div class="col-md-9" role="main">

<p><a name="pgz"></a></p>
<h1 id="pgz">pgz<a class="headerlink" href="#pgz" title="Permanent link">&para;</a></h1>
<p><a name="pgz.actor"></a></p>
<h1 id="pgzactor">pgz.actor<a class="headerlink" href="#pgzactor" title="Permanent link">&para;</a></h1>
<p>pgz uses the <code>pgzero.actor.Actor</code> implementation a sprite representation.
More inforamation can be found <a href="https://pygame-zero.readthedocs.io/en/stable/builtins.html#actors">here</a></p>
<p><a name="pgz.application"></a></p>
<h1 id="pgzapplication">pgz.application<a class="headerlink" href="#pgzapplication" title="Permanent link">&para;</a></h1>
<p><a name="pgz.application.Application"></a></p>
<h2 id="application">Application<a class="headerlink" href="#application" title="Permanent link">&para;</a></h2>
<pre><code class="language-python">class Application()
</code></pre>
<p>The idea and the original code was taken from <a href="https://github.com/Mahi/EzPyGame">EzPyGame</a></p>
<p>A simple wrapper around <code>pygame</code> for running games easily.</p>
<p>Also makes scene management seamless together with the <code>Scene</code> class.</p>
<p><a name="pgz.application.Application.__init__"></a></p>
<h4 id="__init__">__init__<a class="headerlink" href="#__init__" title="Permanent link">&para;</a></h4>
<pre><code class="language-python"> | __init__(title: Optional[str], resolution: Optional[Tuple[int, int]], update_rate: Optional[int] = None)
</code></pre>
<p>Create an instance of the pgz.Application</p>
<p><strong>Arguments</strong>:</p>
<ul>
<li><code>title</code> <em>Optional[str]</em> - title to display in the window&rsquo;s title bar</li>
<li><code>resolution</code> <em>Optional[Tuple[int, int]]</em> - resolution of the game window</li>
<li><code>update_rate</code> <em>Optional[int], optional</em> - how many times per second to update. Defaults to None.</li>
</ul>
<p>If any parameters are left to <code>None</code>, these settings must be
defined either manually through <code>application.&lt;setting&gt; = value</code>
or via <code>Scene</code>&lsquo;s class variable settings.</p>
<p><strong>Examples</strong>:</p>
<pre><code>class Menu(pgz.Scene):
...

class Game(pgz.Scene):
...

app = pgz.Application(
title='My First Application',
resolution=(1280, 720),
update_rate=60,
)
main_menu = Menu()
app.run(main_menu)
</code></pre>
<p><a name="pgz.application.Application.title"></a></p>
<h4 id="title">title<a class="headerlink" href="#title" title="Permanent link">&para;</a></h4>
<pre><code class="language-python"> | @property
 | title() -&gt; str
</code></pre>
<p>Get application title</p>
<p><strong>Returns</strong>:</p>
<ul>
<li><code>str</code> - application title</li>
</ul>
<p><a name="pgz.application.Application.title"></a></p>
<h4 id="title_1">title<a class="headerlink" href="#title_1" title="Permanent link">&para;</a></h4>
<pre><code class="language-python"> | @title.setter
 | title(value: str) -&gt; None
</code></pre>
<p>Change application title</p>
<p><strong>Arguments</strong>:</p>
<ul>
<li><code>value</code> <em>str</em> - application title to set</li>
</ul>
<p><a name="pgz.application.Application.resolution"></a></p>
<h4 id="resolution">resolution<a class="headerlink" href="#resolution" title="Permanent link">&para;</a></h4>
<pre><code class="language-python"> | @property
 | resolution() -&gt; Tuple[int, int]
</code></pre>
<p>Get application screen resolution</p>
<p><strong>Returns</strong>:</p>
<p>Tuple[int, int]: application screen resolution</p>
<p><a name="pgz.application.Application.resolution"></a></p>
<h4 id="resolution_1">resolution<a class="headerlink" href="#resolution_1" title="Permanent link">&para;</a></h4>
<pre><code class="language-python"> | @resolution.setter
 | resolution(value: Tuple[int, int]) -&gt; None
</code></pre>
<p>Change application screen resolution</p>
<p><strong>Arguments</strong>:</p>
<ul>
<li><code>value</code> <em>Tuple[int, int]</em> - application screen resolution to use</li>
</ul>
<p><a name="pgz.application.Application.update_rate"></a></p>
<h4 id="update_rate">update_rate<a class="headerlink" href="#update_rate" title="Permanent link">&para;</a></h4>
<pre><code class="language-python"> | @property
 | update_rate() -&gt; int
</code></pre>
<p>Get application update rate</p>
<p><strong>Returns</strong>:</p>
<ul>
<li><code>int</code> - application update rate</li>
</ul>
<p><a name="pgz.application.Application.update_rate"></a></p>
<h4 id="update_rate_1">update_rate<a class="headerlink" href="#update_rate_1" title="Permanent link">&para;</a></h4>
<pre><code class="language-python"> | @update_rate.setter
 | update_rate(value: int) -&gt; None
</code></pre>
<p>Change application update rate</p>
<p><strong>Arguments</strong>:</p>
<ul>
<li><code>value</code> <em>int</em> - application update rate to set</li>
</ul>
<p><a name="pgz.application.Application.screen"></a></p>
<h4 id="screen">screen<a class="headerlink" href="#screen" title="Permanent link">&para;</a></h4>
<pre><code class="language-python"> | @property
 | screen() -&gt; Screen
</code></pre>
<p>Get application screen object</p>
<p><strong>Returns</strong>:</p>
<ul>
<li><code>Screen</code> - application screen object</li>
</ul>
<p><a name="pgz.application.Application.keyboard"></a></p>
<h4 id="keyboard">keyboard<a class="headerlink" href="#keyboard" title="Permanent link">&para;</a></h4>
<pre><code class="language-python"> | @property
 | keyboard() -&gt; Keyboard
</code></pre>
<p>Get <code>Keyboard</code> object.</p>
<p><strong>Returns</strong>:</p>
<ul>
<li><code>Keyboard</code> - keyboard object</li>
</ul>
<p><a name="pgz.application.Application.clock"></a></p>
<h4 id="clock">clock<a class="headerlink" href="#clock" title="Permanent link">&para;</a></h4>
<pre><code class="language-python"> | @property
 | clock() -&gt; Clock
</code></pre>
<p>Get <code>Clock</code> object.</p>
<p>Actually returns the global clock object.</p>
<p><strong>Returns</strong>:</p>
<ul>
<li><code>Clock</code> - clock object</li>
</ul>
<p><a name="pgz.application.Application.active_scene"></a></p>
<h4 id="active_scene">active_scene<a class="headerlink" href="#active_scene" title="Permanent link">&para;</a></h4>
<pre><code class="language-python"> | @property
 | active_scene() -&gt; Optional[Scene]
</code></pre>
<p>Get currently active scene.</p>
<p>Can be <code>None</code>.</p>
<p><strong>Returns</strong>:</p>
<ul>
<li><code>Optional[Scene]</code> - currently active scene</li>
</ul>
<p><a name="pgz.application.Application.change_scene"></a></p>
<h4 id="change_scene">change_scene<a class="headerlink" href="#change_scene" title="Permanent link">&para;</a></h4>
<pre><code class="language-python"> | change_scene(scene: Optional[Scene]) -&gt; None
</code></pre>
<p>Change the currently active scene.</p>
<p>This will invoke <code>Scene.on_exit</code> and
<code>Scene.on_enter</code> methods on the switching scenes.</p>
<p>If <code>None</code> is provided, the application&rsquo;s execution will end.</p>
<p><strong>Arguments</strong>:</p>
<ul>
<li><code>scene</code> <em>Optional[Scene]</em> - the scene to change into</li>
</ul>
<p><a name="pgz.application.Application.run"></a></p>
<h4 id="run">run<a class="headerlink" href="#run" title="Permanent link">&para;</a></h4>
<pre><code class="language-python"> | run(scene: Optional[Scene] = None) -&gt; None
</code></pre>
<p>Execute the application.</p>
<p><strong>Arguments</strong>:</p>
<ul>
<li><code>scene</code> <em>Optional[Scene], optional</em> - scene to start the execution from. Defaults to None.</li>
</ul>
<p><a name="pgz.clock"></a></p>
<h1 id="pgzclock">pgz.clock<a class="headerlink" href="#pgzclock" title="Permanent link">&para;</a></h1>
<p>pgz uses the <code>pgzero.clock.Clock</code> implementation for scheduling game events.
More inforamation can be found <a href="https://pygame-zero.readthedocs.io/en/stable/builtins.html#clock">here</a></p>
<p><a name="pgz.keyboard"></a></p>
<h1 id="pgzkeyboard">pgz.keyboard<a class="headerlink" href="#pgzkeyboard" title="Permanent link">&para;</a></h1>
<p>pgz uses the <code>pgzero.keyboard.Keyboard</code> implementation for tracking the keyboard state.
More inforamation can be found <a href="https://pygame-zero.readthedocs.io/en/stable/builtins.html#the-keyboard">here</a></p>
<p><a name="pgz.keyboard.Keyboard"></a></p>
<h2 id="keyboard_1">Keyboard<a class="headerlink" href="#keyboard_1" title="Permanent link">&para;</a></h2>
<pre><code class="language-python">class Keyboard()
</code></pre>
<p>The current state of the keyboard.</p>
<p>Each attribute represents a key. For example,</p>
<pre><code>keyboard.a
</code></pre>
<p>is True if the &lsquo;A&rsquo; key is depressed, and False otherwise.</p>
<p><a name="pgz.loaders"></a></p>
<h1 id="pgzloaders">pgz.loaders<a class="headerlink" href="#pgzloaders" title="Permanent link">&para;</a></h1>
<p>pgz uses the <code>pgzero.loaders</code> module implementation for the source managemens.
More inforamation can be found <a href="https://pygame-zero.readthedocs.io/en/stable/builtins.html#resource-loading">here</a></p>
<p>The extension was provided by pgz is the <code>MapLoader</code> resource loader, which loads TMX tiled maps in the same manner as all other resources are loaded</p>
<p><strong>Examples</strong>:</p>
<p>The example of default.tmx file loading is shown below:</p>
<pre><code>tmx = pgz.maps.default
</code></pre>
<p><a name="pgz.multiplayer"></a></p>
<h1 id="pgzmultiplayer">pgz.multiplayer<a class="headerlink" href="#pgzmultiplayer" title="Permanent link">&para;</a></h1>
<p>Set of tools for converting you singleplayer game to the multiplayer one.</p>
<p><a name="pgz.multiplayer.multiplayer_scene"></a></p>
<h1 id="pgzmultiplayermultiplayer_scene">pgz.multiplayer.multiplayer_scene<a class="headerlink" href="#pgzmultiplayermultiplayer_scene" title="Permanent link">&para;</a></h1>
<p><a name="pgz.multiplayer.multiplayer_scene.MultiplayerSceneServer"></a></p>
<h2 id="multiplayersceneserver">MultiplayerSceneServer<a class="headerlink" href="#multiplayersceneserver" title="Permanent link">&para;</a></h2>
<pre><code class="language-python">class MultiplayerSceneServer()
</code></pre>
<p>Scene server implementation.</p>
<p>MultiplayerSceneServer opens a WebSocket server and instantiate a pgz.Scene per connected player(client):</p>
<pre><code>tmx = pgz.maps.default
map = pgz.ScrollMap((1280, 720), tmx, [&quot;Islands&quot;])

# Build and start game server
self.server = pgz.MultiplayerSceneServer(map, GameScene)
self.server.start_server(port=self.port)
</code></pre>
<p>All the scenes will share the map object and collision detector object. So, the communication between different players scenes is done with collision detection.
If one scene shoots the cannon ball (by implementing the CannonBall actor and adding its instance to the map):</p>
<pre><code>def on_mouse_down(self, pos, button):
start_point = self.calc_cannon_ball_start_pos(pos)
if start_point:
ball = CannonBall(pos=start_point, target=pos)
self.add_actor(ball, group_name=&quot;cannon_balls&quot;)
</code></pre>
<p>Another player(scene) might be harmed by the cannon ball using the collision detection:</p>
<pre><code>def update(self, dt):
super().update(dt)

cannon_ball = self.collide_group(self.ship, &quot;cannon_balls&quot;)
if cannon_ball:
# pgz.sounds.arrr.play()
self.ship.health -= cannon_ball.hit_rate * dt
</code></pre>
<p><a name="pgz.multiplayer.multiplayer_scene.MultiplayerSceneServer.__init__"></a></p>
<h4 id="__init___1">__init__<a class="headerlink" href="#__init___1" title="Permanent link">&para;</a></h4>
<pre><code class="language-python"> | __init__(map: ScrollMap, HeadlessSceneClass: Scene)
</code></pre>
<p>Create MultiplayerSceneServer instance.</p>
<p><strong>Arguments</strong>:</p>
<ul>
<li><code>map</code> <em>ScrollMap</em> - a <code>pgz.ScrollMap</code> object. Will be shared across all the scenes in the server</li>
<li><code>HeadlessSceneClass</code> <em>Callable</em> - a scene class. HeadlessSceneClass will be used as a scene object factory.</li>
</ul>
<p><a name="pgz.multiplayer.multiplayer_scene.MultiplayerSceneServer.update"></a></p>
<h4 id="update">update<a class="headerlink" href="#update" title="Permanent link">&para;</a></h4>
<pre><code class="language-python"> | update(dt: float) -&gt; None
</code></pre>
<p>Update method similar to the <code>pgz.scene.Scene.update</code> method.</p>
<p><strong>Arguments</strong>:</p>
<ul>
<li><code>dt</code> <em>float</em> - time in milliseconds since the last update</li>
</ul>
<p><a name="pgz.multiplayer.multiplayer_scene.MultiplayerSceneServer.start_server"></a></p>
<h4 id="start_server">start_server<a class="headerlink" href="#start_server" title="Permanent link">&para;</a></h4>
<pre><code class="language-python"> | start_server(host: str = &quot;localhost&quot;, port: int = 8765) -&gt; None
</code></pre>
<p>Start the scene server.</p>
<p><strong>Arguments</strong>:</p>
<ul>
<li><code>host</code> <em>str, optional</em> - host name. Defaults to &ldquo;localhost&rdquo;.</li>
<li><code>port</code> <em>int, optional</em> - port number for listeting of a incoming WebSocket connections. Defaults to 8765.</li>
</ul>
<p><a name="pgz.multiplayer.multiplayer_scene.MultiplayerSceneServer.stop_server"></a></p>
<h4 id="stop_server">stop_server<a class="headerlink" href="#stop_server" title="Permanent link">&para;</a></h4>
<pre><code class="language-python"> | stop_server() -&gt; None
</code></pre>
<p>Stop the server and disconnect all the clients</p>
<p><a name="pgz.multiplayer.multiplayer_scene.RemoteSceneClient"></a></p>
<h2 id="remotesceneclient">RemoteSceneClient<a class="headerlink" href="#remotesceneclient" title="Permanent link">&para;</a></h2>
<pre><code class="language-python">class RemoteSceneClient(MapScene)
</code></pre>
<p>pgz.RemoteSceneClient allows to communicate with pgz.MultiplayerSceneServer and render the remote scene locally:</p>
<pre><code>data = self.menu.get_input_data()
server_url = data[&quot;server_url&quot;]

tmx = pgz.maps.default
map = pgz.ScrollMap(app.resolution, tmx, [&quot;Islands&quot;])
game = pgz.RemoteSceneClient(map, server_url, client_data={&quot;name&quot;: data[&quot;name&quot;]})
</code></pre>
<p>Pay attention that client process needs to have access to the same external resources (like map files, images,&hellip;) as the game server.</p>
<p>Pay attention that the <code>RemoteSceneClient</code> uses <code>pgz.RPCScreenClient</code> instead of <code>pgz.Screen</code>.</p>
<p><a name="pgz.multiplayer.multiplayer_scene.RemoteSceneClient.__init__"></a></p>
<h4 id="__init___2">__init__<a class="headerlink" href="#__init___2" title="Permanent link">&para;</a></h4>
<pre><code class="language-python"> | __init__(map: ScrollMap, server_url: str, client_data: JSON = {}) -&gt; None
</code></pre>
<p>Create a remote scene client object.</p>
<p><code>client_data</code> will be send to the remote scene object. The common usage - remote scene configuration.
For example the used select the players avatar image: the image name should be a part of the client_data object.
So the remote scene will be able to load a correct sprite and the actor&rsquo;s state with other clients.</p>
<p><strong>Arguments</strong>:</p>
<ul>
<li><code>map</code> <em>ScrollMap</em> - map object will be used for actors management and rendering</li>
<li><code>server_url</code> <em>str</em> - remote server URL</li>
<li><code>client_data</code> <em>JSON, optional</em> - data will be sent to the remote scene object. Defaults to {}.</li>
</ul>
<p><a name="pgz.multiplayer.multiplayer_scene.RemoteSceneClient.on_exit"></a></p>
<h4 id="on_exit">on_exit<a class="headerlink" href="#on_exit" title="Permanent link">&para;</a></h4>
<pre><code class="language-python"> | on_exit(next_scene: Optional[Scene]) -&gt; None
</code></pre>
<p>Overriden deinitialization method</p>
<p><strong>Arguments</strong>:</p>
<ul>
<li><code>next_scene</code> <em>Optional[Scene]</em> - next scene to run</li>
</ul>
<p><a name="pgz.multiplayer.multiplayer_scene.RemoteSceneClient.on_enter"></a></p>
<h4 id="on_enter">on_enter<a class="headerlink" href="#on_enter" title="Permanent link">&para;</a></h4>
<pre><code class="language-python"> | on_enter(previous_scene: Optional[Scene]) -&gt; None
</code></pre>
<p>Overriden initialization method</p>
<p><strong>Arguments</strong>:</p>
<ul>
<li><code>previous_scene</code> <em>Optional[Scene]</em> - previous scene was running</li>
</ul>
<p><a name="pgz.multiplayer.multiplayer_scene.RemoteSceneClient.update"></a></p>
<h4 id="update_1">update<a class="headerlink" href="#update_1" title="Permanent link">&para;</a></h4>
<pre><code class="language-python"> | update(dt: float) -&gt; None
</code></pre>
<p>Overriden update method</p>
<p><strong>Arguments</strong>:</p>
<ul>
<li><code>dt</code> <em>float</em> - time in milliseconds since the last update</li>
</ul>
<p><a name="pgz.multiplayer.multiplayer_scene.RemoteSceneClient.draw"></a></p>
<h4 id="draw">draw<a class="headerlink" href="#draw" title="Permanent link">&para;</a></h4>
<pre><code class="language-python"> | draw(screen: Screen) -&gt; None
</code></pre>
<p>Overriden rendering method</p>
<p><strong>Arguments</strong>:</p>
<ul>
<li><code>screen</code> <em>Screen</em> - screen to draw the scene on</li>
</ul>
<p><a name="pgz.multiplayer.multiplayer_scene.RemoteSceneClient.handle_event"></a></p>
<h4 id="handle_event">handle_event<a class="headerlink" href="#handle_event" title="Permanent link">&para;</a></h4>
<pre><code class="language-python"> | handle_event(event: pygame.event.Event) -&gt; None
</code></pre>
<p>Overriden event handler</p>
<p>Events will be accumulated internally and flushed all together to the remote scene.</p>
<p><strong>Arguments</strong>:</p>
<ul>
<li><code>event</code> <em>pygame.event.Event</em> - pygame event object</li>
</ul>
<p><a name="pgz.multiplayer.multiplayer_scene.RemoteSceneClient.connect_to_server"></a></p>
<h4 id="connect_to_server">connect_to_server<a class="headerlink" href="#connect_to_server" title="Permanent link">&para;</a></h4>
<pre><code class="language-python"> | async connect_to_server(attempts: int = 10) -&gt; bool
</code></pre>
<p>Connect to the remote scene server.</p>
<p><strong>Arguments</strong>:</p>
<ul>
<li><code>attempts</code> <em>int, optional</em> - number of attempts to connect. Defaults to 10.</li>
</ul>
<p><strong>Returns</strong>:</p>
<ul>
<li><code>bool</code> - True if connected successfully</li>
</ul>
<p><a name="pgz.multiplayer.rpc"></a></p>
<h1 id="pgzmultiplayerrpc">pgz.multiplayer.rpc<a class="headerlink" href="#pgzmultiplayerrpc" title="Permanent link">&para;</a></h1>
<p><a name="pgz.multiplayer.screen_rpc"></a></p>
<h1 id="pgzmultiplayerscreen_rpc">pgz.multiplayer.screen_rpc<a class="headerlink" href="#pgzmultiplayerscreen_rpc" title="Permanent link">&para;</a></h1>
<p><a name="pgz.multiplayer.screen_rpc.RPCSurfacePainter"></a></p>
<h2 id="rpcsurfacepainter">RPCSurfacePainter<a class="headerlink" href="#rpcsurfacepainter" title="Permanent link">&para;</a></h2>
<pre><code class="language-python">class RPCSurfacePainter()
</code></pre>
<p>Interface to pygame.draw that is bound to a surface.</p>
<p><a name="pgz.multiplayer.screen_rpc.RPCSurfacePainter.line"></a></p>
<h4 id="line">line<a class="headerlink" href="#line" title="Permanent link">&para;</a></h4>
<pre><code class="language-python"> | line(start: Tuple[Any, Any], end: Tuple[Any, Any], color: Any, width: int = 1) -&gt; None
</code></pre>
<p>Draw a line from start to end.</p>
<p><a name="pgz.multiplayer.screen_rpc.RPCSurfacePainter.circle"></a></p>
<h4 id="circle">circle<a class="headerlink" href="#circle" title="Permanent link">&para;</a></h4>
<pre><code class="language-python"> | circle(pos: Tuple[Any, Any], radius: float, color: Any, width: int = 1) -&gt; None
</code></pre>
<p>Draw a circle.</p>
<p><a name="pgz.multiplayer.screen_rpc.RPCSurfacePainter.filled_circle"></a></p>
<h4 id="filled_circle">filled_circle<a class="headerlink" href="#filled_circle" title="Permanent link">&para;</a></h4>
<pre><code class="language-python"> | filled_circle(pos: Tuple[Any, Any], radius: float, color: Any) -&gt; None
</code></pre>
<p>Draw a filled circle.</p>
<p><a name="pgz.multiplayer.screen_rpc.RPCSurfacePainter.polygon"></a></p>
<h4 id="polygon">polygon<a class="headerlink" href="#polygon" title="Permanent link">&para;</a></h4>
<pre><code class="language-python"> | polygon(points: List[Tuple[Any, Any]], color: Any) -&gt; None
</code></pre>
<p>Draw a polygon.</p>
<p><a name="pgz.multiplayer.screen_rpc.RPCSurfacePainter.filled_polygon"></a></p>
<h4 id="filled_polygon">filled_polygon<a class="headerlink" href="#filled_polygon" title="Permanent link">&para;</a></h4>
<pre><code class="language-python"> | filled_polygon(points: List[Tuple[Any, Any]], color: Any) -&gt; None
</code></pre>
<p>Draw a filled polygon.</p>
<p><a name="pgz.multiplayer.screen_rpc.RPCSurfacePainter.rect"></a></p>
<h4 id="rect">rect<a class="headerlink" href="#rect" title="Permanent link">&para;</a></h4>
<pre><code class="language-python"> | rect(rect: ZRect, color: Any, width: int = 1) -&gt; None
</code></pre>
<p>Draw a rectangle.</p>
<p><a name="pgz.multiplayer.screen_rpc.RPCSurfacePainter.filled_rect"></a></p>
<h4 id="filled_rect">filled_rect<a class="headerlink" href="#filled_rect" title="Permanent link">&para;</a></h4>
<pre><code class="language-python"> | filled_rect(rect: ZRect, color: Any) -&gt; None
</code></pre>
<p>Draw a filled rectangle.</p>
<p><a name="pgz.multiplayer.screen_rpc.RPCSurfacePainter.text"></a></p>
<h4 id="text">text<a class="headerlink" href="#text" title="Permanent link">&para;</a></h4>
<pre><code class="language-python"> | text(*args: Any, **kwargs: Any) -&gt; None
</code></pre>
<p>Draw text to the screen.</p>
<p><a name="pgz.multiplayer.screen_rpc.RPCSurfacePainter.textbox"></a></p>
<h4 id="textbox">textbox<a class="headerlink" href="#textbox" title="Permanent link">&para;</a></h4>
<pre><code class="language-python"> | textbox(*args: Any, **kwargs: Any) -&gt; None
</code></pre>
<p>Draw text to the screen, wrapped to fit a box</p>
<p><a name="pgz.multiplayer.screen_rpc.RPCScreenServer"></a></p>
<h2 id="rpcscreenserver">RPCScreenServer<a class="headerlink" href="#rpcscreenserver" title="Permanent link">&para;</a></h2>
<pre><code class="language-python">class RPCScreenServer()
</code></pre>
<p><a name="pgz.multiplayer.screen_rpc.RPCScreenServer.bounds"></a></p>
<h4 id="bounds">bounds<a class="headerlink" href="#bounds" title="Permanent link">&para;</a></h4>
<pre><code class="language-python"> | bounds() -&gt; ZRect
</code></pre>
<p>Return a Rect representing the bounds of the screen.</p>
<p><a name="pgz.multiplayer.screen_rpc.RPCScreenServer.clear"></a></p>
<h4 id="clear">clear<a class="headerlink" href="#clear" title="Permanent link">&para;</a></h4>
<pre><code class="language-python"> | clear() -&gt; None
</code></pre>
<p>Clear the screen to black.</p>
<p><a name="pgz.rect"></a></p>
<h1 id="pgzrect">pgz.rect<a class="headerlink" href="#pgzrect" title="Permanent link">&para;</a></h1>
<p>pgz uses the <code>pgzero.rect.ZRect</code> implementation for a rectangle representation.
More inforamation can be found <a href="https://pygame-zero.readthedocs.io/en/stable/builtins.html#rect">here</a></p>
<p><a name="pgz.scene"></a></p>
<h1 id="pgzscene">pgz.scene<a class="headerlink" href="#pgzscene" title="Permanent link">&para;</a></h1>
<p><a name="pgz.scene.Scene"></a></p>
<h2 id="scene">Scene<a class="headerlink" href="#scene" title="Permanent link">&para;</a></h2>
<pre><code class="language-python">class Scene(EventDispatcher)
</code></pre>
<p>The idea and the original code was taken from <a href="https://github.com/Mahi/EzPyGame">EzPyGame</a></p>
<p>An isolated scene which can be ran by an application.</p>
<p>Create your own scene by subclassing and overriding any methods.</p>
<p><strong>Example</strong>:</p>
<pre><code>class Menu(Scene):

def __init__(self):
self.font = pygame.font.Font(...)

def on_enter(self, previous_scene):
self.title = 'Main Menu'
self.resolution = (640, 480)
self.update_rate = 30

def draw(self, screen):
pygame.draw.rect(...)
text = self.font.render(...)
screen.blit(text, ...)

def handle_event(self, event):
if event.type == pygame.MOUSEBUTTONUP:
if event.button == 1:
game_size = self._get_game_size(event.pos)
self.change_scene(Game(game_size))

def _get_game_size(self, mouse_pos_upon_click):
...


class Game(pgz.Scene):
title = 'The Game!'
resolution = (1280, 720)
update_rate = 60

def __init__(self, size):
super().__init__()
self.size = size
self.player = ...
...

def on_enter(self, previous_scene):
super().on_enter(previous_scene)
self.previous_scene = previous_scene

def draw(self, screen):
self.player.draw(screen)
for enemy in self.enemies:
...

def update(self, dt):
self.player.move(dt)
...
if self.player.is_dead():
self.change_scene(self.previous_scene)
elif self.player_won():
self.change_scene(...)

def handle_event(self, event):
...  # Player movement etc.
</code></pre>
<p>The above two classes use different approaches for changing
the application&rsquo;s settings when the scene is entered:</p>
<ol>
<li>Manually set them in <code>on_enter</code>, as seen in <code>Menu</code></li>
<li>Use class variables, as I did with <code>Game</code></li>
</ol>
<p>When using class variables (2), you can leave out any setting
(defaults to <code>None</code>) to not override that particular setting.
If you override <code>on_enter</code> in the subclass, you must call
<code>super().on_enter(previous_scene)</code> to use the class variables.</p>
<p>These settings can further be overridden in individual instances:</p>
<pre><code>my_scene0 = MyScene()
my_scene0.resolution = (1280, 720)
my_scene1 = MyScene(title='My Second Awesome Scene')
</code></pre>
<p><strong>Example</strong>:</p>
<p>Shortcuts foe event gandling while <code>Scene</code> subclassing.</p>
<pre><code>def on_mouse_up(self, pos, button):
# Override this for easier events handling.
pass

def on_mouse_down(self, pos, button):
# Override this for easier events handling.
pass

def on_mouse_move(self, pos):
# Override this for easier events handling.
pass

def on_key_down(self, key):
# Override this for easier events handling.
pass

def on_key_up(self, key):
# Override this for easier events handling.
pass
</code></pre>
<p><a name="pgz.scene.Scene.scene_uuid"></a></p>
<h4 id="scene_uuid">scene_uuid<a class="headerlink" href="#scene_uuid" title="Permanent link">&para;</a></h4>
<pre><code class="language-python"> | @property
 | scene_uuid() -&gt; str
</code></pre>
<p>Get scene UUID.</p>
<p><a name="pgz.scene.Scene.client_data"></a></p>
<h4 id="client_data">client_data<a class="headerlink" href="#client_data" title="Permanent link">&para;</a></h4>
<pre><code class="language-python"> | @property
 | client_data() -&gt; Dict[str, Any]
</code></pre>
<p>Get data provided by client side.</p>
<p><a name="pgz.scene.Scene.title"></a></p>
<h4 id="title_2">title<a class="headerlink" href="#title_2" title="Permanent link">&para;</a></h4>
<pre><code class="language-python"> | @property
 | title() -&gt; str
</code></pre>
<p>Get application title</p>
<p><strong>Returns</strong>:</p>
<ul>
<li><code>str</code> - application title</li>
</ul>
<p><a name="pgz.scene.Scene.title"></a></p>
<h4 id="title_3">title<a class="headerlink" href="#title_3" title="Permanent link">&para;</a></h4>
<pre><code class="language-python"> | @title.setter
 | title(value: str) -&gt; None
</code></pre>
<p>Change application title</p>
<p><strong>Arguments</strong>:</p>
<ul>
<li><code>value</code> <em>str</em> - application title to set</li>
</ul>
<p><a name="pgz.scene.Scene.resolution"></a></p>
<h4 id="resolution_2">resolution<a class="headerlink" href="#resolution_2" title="Permanent link">&para;</a></h4>
<pre><code class="language-python"> | @property
 | resolution() -&gt; Tuple[int, int]
</code></pre>
<p>Get application screen resolution</p>
<p><strong>Returns</strong>:</p>
<p>Tuple[int, int]: application screen resolution</p>
<p><a name="pgz.scene.Scene.resolution"></a></p>
<h4 id="resolution_3">resolution<a class="headerlink" href="#resolution_3" title="Permanent link">&para;</a></h4>
<pre><code class="language-python"> | @resolution.setter
 | resolution(value: Tuple[int, int]) -&gt; None
</code></pre>
<p>Change application screen resolution</p>
<p><strong>Arguments</strong>:</p>
<ul>
<li><code>value</code> <em>Tuple[int, int]</em> - application screen resolution to use</li>
</ul>
<p><a name="pgz.scene.Scene.update_rate"></a></p>
<h4 id="update_rate_2">update_rate<a class="headerlink" href="#update_rate_2" title="Permanent link">&para;</a></h4>
<pre><code class="language-python"> | @property
 | update_rate() -&gt; int
</code></pre>
<p>Get application update rate</p>
<p><strong>Returns</strong>:</p>
<ul>
<li><code>int</code> - application update rate</li>
</ul>
<p><a name="pgz.scene.Scene.update_rate"></a></p>
<h4 id="update_rate_3">update_rate<a class="headerlink" href="#update_rate_3" title="Permanent link">&para;</a></h4>
<pre><code class="language-python"> | @update_rate.setter
 | update_rate(value: int) -&gt; None
</code></pre>
<p>Change application update rate</p>
<p><strong>Arguments</strong>:</p>
<ul>
<li><code>value</code> <em>int</em> - application update rate to set</li>
</ul>
<p><a name="pgz.scene.Scene.clock"></a></p>
<h4 id="clock_1">clock<a class="headerlink" href="#clock_1" title="Permanent link">&para;</a></h4>
<pre><code class="language-python"> | @property
 | clock() -&gt; Clock
</code></pre>
<p>Get <code>Clock</code> object.</p>
<p>Actually returns the global clock object.</p>
<p><strong>Returns</strong>:</p>
<ul>
<li><code>Clock</code> - clock object</li>
</ul>
<p><a name="pgz.scene.Scene.keyboard"></a></p>
<h4 id="keyboard_2">keyboard<a class="headerlink" href="#keyboard_2" title="Permanent link">&para;</a></h4>
<pre><code class="language-python"> | @property
 | keyboard() -&gt; Keyboard
</code></pre>
<p>Get <code>Keyboard</code> object.</p>
<p><strong>Returns</strong>:</p>
<ul>
<li><code>Keyboard</code> - keyboard object</li>
</ul>
<p><a name="pgz.scene.Scene.draw"></a></p>
<h4 id="draw_1">draw<a class="headerlink" href="#draw_1" title="Permanent link">&para;</a></h4>
<pre><code class="language-python"> | draw(screen: Screen) -&gt; None
</code></pre>
<p>Override this with the scene drawing.</p>
<p><strong>Arguments</strong>:</p>
<ul>
<li><code>screen</code> <em>Screen</em> - screen to draw the scene on</li>
</ul>
<p><a name="pgz.scene.Scene.update"></a></p>
<h4 id="update_2">update<a class="headerlink" href="#update_2" title="Permanent link">&para;</a></h4>
<pre><code class="language-python"> | update(dt: float) -&gt; None
</code></pre>
<p>Override this with the scene update tick.</p>
<p><strong>Arguments</strong>:</p>
<ul>
<li><code>dt</code> <em>float</em> - time in milliseconds since the last update</li>
</ul>
<p><a name="pgz.scene.Scene.handle_event"></a></p>
<h4 id="handle_event_1">handle_event<a class="headerlink" href="#handle_event_1" title="Permanent link">&para;</a></h4>
<pre><code class="language-python"> | handle_event(event: pygame.event.Event) -&gt; None
</code></pre>
<p>Override this to handle an event in the scene.</p>
<p>All of <code>pygame</code>&lsquo;s events are sent here, so filtering
should be applied manually in the subclass.</p>
<p><strong>Arguments</strong>:</p>
<ul>
<li><code>event</code> <em>pygame.event.Event</em> - event to handle</li>
</ul>
<p><a name="pgz.scene.Scene.on_enter"></a></p>
<h4 id="on_enter_1">on_enter<a class="headerlink" href="#on_enter_1" title="Permanent link">&para;</a></h4>
<pre><code class="language-python"> | on_enter(previous_scene: Optional[&quot;Scene&quot;]) -&gt; None
</code></pre>
<p>Override this to initialize upon scene entering.</p>
<p>If you override this method and want to use class variables
to change the application&rsquo;s settings, you must call
<code>super().on_enter(previous_scene)</code> in the subclass.</p>
<p><strong>Arguments</strong>:</p>
<ul>
<li><code>previous_scene</code> <em>Optional[Scene]</em> - previous scene was running</li>
</ul>
<p><a name="pgz.scene.Scene.on_exit"></a></p>
<h4 id="on_exit_1">on_exit<a class="headerlink" href="#on_exit_1" title="Permanent link">&para;</a></h4>
<pre><code class="language-python"> | on_exit(next_scene: Optional[&quot;Scene&quot;]) -&gt; None
</code></pre>
<p>Override this to deinitialize upon scene exiting.</p>
<p><strong>Arguments</strong>:</p>
<ul>
<li><code>next_scene</code> <em>Optional[Scene]</em> - next scene to run</li>
</ul>
<p><a name="pgz.scenes"></a></p>
<h1 id="pgzscenes">pgz.scenes<a class="headerlink" href="#pgzscenes" title="Permanent link">&para;</a></h1>
<p>pgz provides an implementation of a few tipical scene classes subclassed from the <code>pgz.Scene</code>.</p>
<ul>
<li><code>pgz.MenuScene</code> - implements game menu rendering as a pgz.Scene subclass</li>
<li><code>pgz.ActorScene</code> - implements the basic actors managements, updates, rendering logic and actors collision detection.</li>
<li><code>pgz.MapScene</code> - extends pgz.ActorScene for games based on the tiled maps. It also implements the tiles collision detection.</li>
<li><code>pgz.RemoteSceneClient</code> - allows to render the view of remote pgz.MapScene or pgz.ActorScene using WebSocket connection. It might be useful handy for building of a multiplayer game</li>
</ul>
<p><a name="pgz.scenes.actor_scene"></a></p>
<h1 id="pgzscenesactor_scene">pgz.scenes.actor_scene<a class="headerlink" href="#pgzscenesactor_scene" title="Permanent link">&para;</a></h1>
<p><a name="pgz.scenes.actor_scene.ActorScene"></a></p>
<h2 id="actorscene">ActorScene<a class="headerlink" href="#actorscene" title="Permanent link">&para;</a></h2>
<pre><code class="language-python">class ActorScene(Scene)
</code></pre>
<p>Scene implementation for management of multiple actors.</p>
<p>Actors also can be added to different collision groups, which allows easily identify collision of an actor with a specific actor group.</p>
<p><a name="pgz.scenes.actor_scene.ActorScene.__init__"></a></p>
<h4 id="__init___3">__init__<a class="headerlink" href="#__init___3" title="Permanent link">&para;</a></h4>
<pre><code class="language-python"> | __init__() -&gt; None
</code></pre>
<p>Create an ActorScene object</p>
<p><a name="pgz.scenes.actor_scene.ActorScene.set_collision_detector"></a></p>
<h4 id="set_collision_detector">set_collision_detector<a class="headerlink" href="#set_collision_detector" title="Permanent link">&para;</a></h4>
<pre><code class="language-python"> | set_collision_detector(collision_detector: CollisionDetector)
</code></pre>
<p>Set external collsinion detector object.</p>
<p>The default collision detector can be use in the most of the cases.
This method in used by multiplayer.</p>
<p><a name="pgz.scenes.actor_scene.ActorScene.add_actor"></a></p>
<h4 id="add_actor">add_actor<a class="headerlink" href="#add_actor" title="Permanent link">&para;</a></h4>
<pre><code class="language-python"> | add_actor(actor: Actor, group_name: str = &quot;&quot;) -&gt; None
</code></pre>
<p>Add actor to the scene and add the actor to the collision group.</p>
<p><strong>Arguments</strong>:</p>
<ul>
<li><code>actor</code> <em>Actor</em> - actor to add</li>
<li><code>group_name</code> <em>str, optional</em> - Collision group name. Defaults to &ldquo;&rdquo;.</li>
</ul>
<p><a name="pgz.scenes.actor_scene.ActorScene.remove_actor"></a></p>
<h4 id="remove_actor">remove_actor<a class="headerlink" href="#remove_actor" title="Permanent link">&para;</a></h4>
<pre><code class="language-python"> | remove_actor(actor: Actor) -&gt; None
</code></pre>
<p>Remove actor from the scene.</p>
<p>Actor also will be removed from the associated collision detector</p>
<p><strong>Arguments</strong>:</p>
<ul>
<li><code>actor</code> <em>Actor</em> - Actor to be removed</li>
</ul>
<p><a name="pgz.scenes.actor_scene.ActorScene.remove_actors"></a></p>
<h4 id="remove_actors">remove_actors<a class="headerlink" href="#remove_actors" title="Permanent link">&para;</a></h4>
<pre><code class="language-python"> | remove_actors() -&gt; None
</code></pre>
<p>Remove all actors from the scene and the associated collision detector</p>
<p><a name="pgz.scenes.actor_scene.ActorScene.get_actor"></a></p>
<h4 id="get_actor">get_actor<a class="headerlink" href="#get_actor" title="Permanent link">&para;</a></h4>
<pre><code class="language-python"> | get_actor(uuid: str) -&gt; Actor
</code></pre>
<p>Get actor object by its UUID</p>
<p><strong>Arguments</strong>:</p>
<ul>
<li><code>uuid</code> <em>str</em> - UUID of the actor to be retrieved</li>
</ul>
<p><strong>Returns</strong>:</p>
<ul>
<li><code>Actor</code> - Actor associated with the UUID</li>
</ul>
<p><a name="pgz.scenes.actor_scene.ActorScene.get_actors"></a></p>
<h4 id="get_actors">get_actors<a class="headerlink" href="#get_actors" title="Permanent link">&para;</a></h4>
<pre><code class="language-python"> | get_actors() -&gt; List[Actor]
</code></pre>
<p>Get list of actors</p>
<p><strong>Returns</strong>:</p>
<ul>
<li><code>List[Actor]</code> - The list of actors on the scene</li>
</ul>
<p><a name="pgz.scenes.actor_scene.ActorScene.collide_group"></a></p>
<h4 id="collide_group">collide_group<a class="headerlink" href="#collide_group" title="Permanent link">&para;</a></h4>
<pre><code class="language-python"> | collide_group(actor: Actor, group_name: str = &quot;&quot;) -&gt; Optional[Actor]
</code></pre>
<p>Detect collision of a ginen actor with the actors in requested collsion group.</p>
<p><strong>Arguments</strong>:</p>
<ul>
<li><code>actor</code> <em>Actor</em> - actor to detect collisions with</li>
<li><code>group_name</code> <em>str, optional</em> - Collision group name. Defaults to &ldquo;&rdquo;.</li>
</ul>
<p><strong>Returns</strong>:</p>
<ul>
<li><code>Optional[Actor]</code> - A collins actor in the specified collision group</li>
</ul>
<p><a name="pgz.scenes.actor_scene.ActorScene.draw"></a></p>
<h4 id="draw_2">draw<a class="headerlink" href="#draw_2" title="Permanent link">&para;</a></h4>
<pre><code class="language-python"> | draw(surface: Screen) -&gt; None
</code></pre>
<p>Overriden rendering method</p>
<p>Implementation of the update method for the ActorScene.</p>
<p>The ActorScene implementation renders all the actorts attached to the scene.</p>
<p><strong>Arguments</strong>:</p>
<ul>
<li><code>screen</code> <em>Screen</em> - screen to draw the scene on</li>
</ul>
<p><a name="pgz.scenes.actor_scene.ActorScene.update"></a></p>
<h4 id="update_3">update<a class="headerlink" href="#update_3" title="Permanent link">&para;</a></h4>
<pre><code class="language-python"> | update(dt: float) -&gt; None
</code></pre>
<p>Overriden update method</p>
<p>Implementation of the update method for the ActorScene.</p>
<p>This method updates all the actors attached to the scene.</p>
<p><strong>Arguments</strong>:</p>
<ul>
<li><code>dt</code> <em>float</em> - time in milliseconds since the last update</li>
</ul>
<p><a name="pgz.scenes.map_scene"></a></p>
<h1 id="pgzscenesmap_scene">pgz.scenes.map_scene<a class="headerlink" href="#pgzscenesmap_scene" title="Permanent link">&para;</a></h1>
<p><a name="pgz.scenes.map_scene.MapScene"></a></p>
<h2 id="mapscene">MapScene<a class="headerlink" href="#mapscene" title="Permanent link">&para;</a></h2>
<pre><code class="language-python">class MapScene(ActorScene)
</code></pre>
<p>Scene implementation for Tiled map management.</p>
<p>Extends functionality ActorScene, but in case of MapScene actors are placed on a map.
The implementation is based on <a href="https://github.com/bitcraft/pyscroll">pyscroll</a>.
A tiled map can be created and modified with wonderful <a href="https://www.mapeditor.org/">Tiled</a> maps editor.</p>
<p>The maps loading and usage is backed by <a href="https://github.com/bitcraft/PyTMX">PyTMX</a></p>
<p>Actors also can be added to different collision groups,
which allows easily identify collision of an actor with a specific actor group</p>
<p><a name="pgz.scenes.map_scene.MapScene.__init__"></a></p>
<h4 id="__init___4">__init__<a class="headerlink" href="#__init___4" title="Permanent link">&para;</a></h4>
<pre><code class="language-python"> | __init__(map: Optional[ScrollMap] = None)
</code></pre>
<p>Create a MapScene object</p>
<p>The map object loading is done with the map loader (a-la pgzero resource loaders). So for loading a map from &ldquo;default.tmx&rdquo; file of the resource directory:</p>
<pre><code>tmx = pgz.maps.default
map = pgz.ScrollMap(app.resolution, tmx, [&quot;Islands&quot;])
</code></pre>
<p><strong>Arguments</strong>:</p>
<ul>
<li><code>map</code> <em>Optional[ScrollMap], optional</em> - Loaded map object. Defaults to None.</li>
</ul>
<p><a name="pgz.scenes.map_scene.MapScene.map"></a></p>
<h4 id="map">map<a class="headerlink" href="#map" title="Permanent link">&para;</a></h4>
<pre><code class="language-python"> | @property
 | map() -&gt; ScrollMap
</code></pre>
<p>Get map object</p>
<p><strong>Returns</strong>:</p>
<ul>
<li><code>ScrollMap</code> - the map object used by the scene</li>
</ul>
<p><a name="pgz.scenes.map_scene.MapScene.set_map"></a></p>
<h4 id="set_map">set_map<a class="headerlink" href="#set_map" title="Permanent link">&para;</a></h4>
<pre><code class="language-python"> | set_map(map)
</code></pre>
<p>Set map object</p>
<p><strong>Arguments</strong>:</p>
<ul>
<li><code>map</code> <em>[type]</em> - map object to set</li>
</ul>
<p><a name="pgz.scenes.map_scene.MapScene.dispatch_event"></a></p>
<h4 id="dispatch_event">dispatch_event<a class="headerlink" href="#dispatch_event" title="Permanent link">&para;</a></h4>
<pre><code class="language-python"> | dispatch_event(event: pygame.event.Event) -&gt; None
</code></pre>
<p>Overriden events dispatch method
Used for mouse cursor position transformation into map &ldquo;world coordinates&rdquo;</p>
<p><strong>Arguments</strong>:</p>
<ul>
<li><code>event</code> <em>pygame.event.Event</em> - pygame Event object</li>
</ul>
<p><a name="pgz.scenes.map_scene.MapScene.update"></a></p>
<h4 id="update_4">update<a class="headerlink" href="#update_4" title="Permanent link">&para;</a></h4>
<pre><code class="language-python"> | update(dt: float) -&gt; None
</code></pre>
<p>Overriden update method
Implementation of the update method for the MapScene.</p>
<p>This method updates all the actors attached to the scene.</p>
<p><strong>Arguments</strong>:</p>
<ul>
<li><code>dt</code> <em>float</em> - time in milliseconds since the last update</li>
</ul>
<p><a name="pgz.scenes.map_scene.MapScene.draw"></a></p>
<h4 id="draw_3">draw<a class="headerlink" href="#draw_3" title="Permanent link">&para;</a></h4>
<pre><code class="language-python"> | draw(screen: Screen) -&gt; None
</code></pre>
<p>Overriden rendering method
Implementation of the update method for the MapScene.</p>
<p>The ActorScene implementation renders all the actorts attached to the scene.</p>
<p><strong>Arguments</strong>:</p>
<ul>
<li><code>screen</code> <em>Screen</em> - screen to draw the scene on</li>
</ul>
<p><a name="pgz.scenes.map_scene.MapScene.add_actor"></a></p>
<h4 id="add_actor_1">add_actor<a class="headerlink" href="#add_actor_1" title="Permanent link">&para;</a></h4>
<pre><code class="language-python"> | add_actor(actor: Actor, central_actor: bool = False, group_name: str = &quot;&quot;) -&gt; None
</code></pre>
<p>Overriden add_actor method
Implementation of the add_actor method for the MapScene.</p>
<p>The ActorScene implementation renders all the actorts attached to the scene.</p>
<p><strong>Arguments</strong>:</p>
<ul>
<li><code>actor</code> <em>Actor</em> - actor to add</li>
<li><code>central_actor</code> <em>bool, optional</em> - Sets the actor to be central actor for the scene. The map view will be centered on the actor. Defaults to False.</li>
<li><code>group_name</code> <em>str, optional</em> - Collision group name. Defaults to &ldquo;&rdquo;.</li>
</ul>
<p><a name="pgz.scenes.map_scene.MapScene.remove_actor"></a></p>
<h4 id="remove_actor_1">remove_actor<a class="headerlink" href="#remove_actor_1" title="Permanent link">&para;</a></h4>
<pre><code class="language-python"> | remove_actor(actor: Actor) -&gt; None
</code></pre>
<p>Overriden remove_actor method
Implementation of the remove_actor method for the MapScene.</p>
<p><strong>Arguments</strong>:</p>
<ul>
<li><code>actor</code> <em>Actor</em> - actor to be removed</li>
</ul>
<p><a name="pgz.scenes.map_scene.MapScene.handle_event"></a></p>
<h4 id="handle_event_2">handle_event<a class="headerlink" href="#handle_event_2" title="Permanent link">&para;</a></h4>
<pre><code class="language-python"> | handle_event(event: pygame.event.Event) -&gt; None
</code></pre>
<p>Overriden event handler
Implementation of the event handler method for the MapScene.</p>
<p><strong>Arguments</strong>:</p>
<ul>
<li><code>event</code> <em>pygame.event.Event</em> - pygame event object</li>
</ul>
<p><a name="pgz.scenes.map_scene.MapScene.collide_map"></a></p>
<h4 id="collide_map">collide_map<a class="headerlink" href="#collide_map" title="Permanent link">&para;</a></h4>
<pre><code class="language-python"> | collide_map(actor: Actor) -&gt; bool
</code></pre>
<p>Detect collision with tiles in the map object used by the scene</p>
<p><strong>Arguments</strong>:</p>
<ul>
<li><code>actor</code> <em>Actor</em> - actor for collision detection</li>
</ul>
<p><strong>Returns</strong>:</p>
<ul>
<li><code>bool</code> - True if the collision with map tiles is detected</li>
</ul>
<p><a name="pgz.scenes.menu_scene"></a></p>
<h1 id="pgzscenesmenu_scene">pgz.scenes.menu_scene<a class="headerlink" href="#pgzscenesmenu_scene" title="Permanent link">&para;</a></h1>
<p><a name="pgz.scenes.menu_scene.MenuScene"></a></p>
<h2 id="menuscene">MenuScene<a class="headerlink" href="#menuscene" title="Permanent link">&para;</a></h2>
<pre><code class="language-python">class MenuScene(Scene)
</code></pre>
<p>Base class for a scenes showing menu.</p>
<p>MenuScene uses <code>pygame_menu.Menu</code> internally, for the additional information follow the link <a href="https://github.com/ppizarror/pygame-menu">pygame-menu</a>.</p>
<p><strong>Examples</strong>:</p>
<pre><code>class Menu(pgz.MenuScene):
def __init__(self):
super().__init__()
import pygame_menu

self.menu = pygame_menu.Menu(300, 400, &quot;Welcome&quot;, theme=pygame_menu.themes.THEME_BLUE)

self.menu.add_text_input(&quot;Name :&quot;, textinput_id=&quot;name&quot;, default=&quot;John Doe&quot;)
self.menu.add_selector('Difficulty :', [('Hard', 1), ('Easy', 2)], onchange=set_difficulty)
self.menu.add_button(&quot;Play&quot;, self.start_the_game)
self.menu.add_button(&quot;Quit&quot;, pygame_menu.events.EXIT)

def start_the_game(self):
data = self.menu.get_input_data()

scene = GameScene()
tmx = pgz.maps.default
map = pgz.ScrollMap(app.resolution, tmx, [&quot;Islands&quot;])
scene.set_map(map)
scene.set_client_data({&quot;name&quot;: data[&quot;name&quot;]})
self.change_scene(scene)
</code></pre>
<p><a name="pgz.scenes.menu_scene.MenuScene.__init__"></a></p>
<h4 id="__init___5">__init__<a class="headerlink" href="#__init___5" title="Permanent link">&para;</a></h4>
<pre><code class="language-python"> | __init__(menu: Optional[pygame_menu.Menu] = None)
</code></pre>
<p>Create <code>MenuScene</code></p>
<p>Receives a menu object as argument or creates its own menu object.</p>
<p><strong>Arguments</strong>:</p>
<ul>
<li><code>menu</code> <em>Optional[pygame_menu.Menu], optional</em> - menu object. Defaults to None.</li>
</ul>
<p><a name="pgz.scenes.menu_scene.MenuScene.menu"></a></p>
<h4 id="menu">menu<a class="headerlink" href="#menu" title="Permanent link">&para;</a></h4>
<pre><code class="language-python"> | @property
 | menu() -&gt; pygame_menu.Menu
</code></pre>
<p>Get the internal <code>pygame_menu.Menu</code> object.</p>
<p><strong>Returns</strong>:</p>
<ul>
<li><code>pygame_menu.Menu</code> - internal menu object.</li>
</ul>
<p><a name="pgz.scenes.menu_scene.MenuScene.draw"></a></p>
<h4 id="draw_4">draw<a class="headerlink" href="#draw_4" title="Permanent link">&para;</a></h4>
<pre><code class="language-python"> | draw(screen: Screen) -&gt; None
</code></pre>
<p>Overriden rendering method
Implementation of the update method for the ActorScene.</p>
<p>The ActorScene implementation renders all the actorts attached to the scene.</p>
<p><strong>Arguments</strong>:</p>
<ul>
<li><code>screen</code> <em>Screen</em> - screen to draw the scene on</li>
</ul>
<p><a name="pgz.scenes.menu_scene.MenuScene.on_exit"></a></p>
<h4 id="on_exit_2">on_exit<a class="headerlink" href="#on_exit_2" title="Permanent link">&para;</a></h4>
<pre><code class="language-python"> | on_exit(next_scene: Optional[Scene]) -&gt; None
</code></pre>
<p>Overriden deinitialization method</p>
<p><strong>Arguments</strong>:</p>
<ul>
<li><code>next_scene</code> <em>Optional[Scene]</em> - next scene to run</li>
</ul>
<p><a name="pgz.scenes.menu_scene.MenuScene.handle_event"></a></p>
<h4 id="handle_event_3">handle_event<a class="headerlink" href="#handle_event_3" title="Permanent link">&para;</a></h4>
<pre><code class="language-python"> | handle_event(event: pygame.event.Event) -&gt; None
</code></pre>
<p>Overriden event handling method method</p>
<p>All of <code>pygame</code>&lsquo;s events are sent here, so filtering
should be applied manually in the subclass.</p>
<p><strong>Arguments</strong>:</p>
<ul>
<li><code>event</code> <em>pygame.event.Event</em> - event to handle</li>
</ul>
<p><a name="pgz.screen"></a></p>
<h1 id="pgzscreen">pgz.screen<a class="headerlink" href="#pgzscreen" title="Permanent link">&para;</a></h1>
<p>pgz uses the <code>pgzero.screen.Screen</code> implementation for the screen object representation and rendering.
More inforamation can be found <a href="https://pygame-zero.readthedocs.io/en/stable/builtins.html#screen">here</a>.</p>
<p><a name="pgz.utils"></a></p>
<h1 id="pgzutils">pgz.utils<a class="headerlink" href="#pgzutils" title="Permanent link">&para;</a></h1>
<p><a name="pgz.utils.collision_detector"></a></p>
<h1 id="pgzutilscollision_detector">pgz.utils.collision_detector<a class="headerlink" href="#pgzutilscollision_detector" title="Permanent link">&para;</a></h1>
<p><a name="pgz.utils.collision_detector.CollisionDetector"></a></p>
<h2 id="collisiondetector">CollisionDetector<a class="headerlink" href="#collisiondetector" title="Permanent link">&para;</a></h2>
<pre><code class="language-python">class CollisionDetector(object)
</code></pre>
<p>Class helper for easier collision detection</p>
<p>The class manages multiple collision groups and can detect a collsion with each one of groups independently.</p>
<p><a name="pgz.utils.collision_detector.CollisionDetector.__init__"></a></p>
<h4 id="__init___6">__init__<a class="headerlink" href="#__init___6" title="Permanent link">&para;</a></h4>
<pre><code class="language-python"> | __init__() -&gt; None
</code></pre>
<p>Create a collision detecor</p>
<p><a name="pgz.utils.collision_detector.CollisionDetector.add_actor"></a></p>
<h4 id="add_actor_2">add_actor<a class="headerlink" href="#add_actor_2" title="Permanent link">&para;</a></h4>
<pre><code class="language-python"> | add_actor(actor: Actor, group_name: str = &quot;&quot;) -&gt; None
</code></pre>
<p>Add an actor to the detector</p>
<p><strong>Arguments</strong>:</p>
<ul>
<li><code>actor</code> <em>Actor</em> - actor to add</li>
<li><code>group_name</code> <em>str, optional</em> - collision group to use. Defaults to &ldquo;&rdquo;.</li>
</ul>
<p><a name="pgz.utils.collision_detector.CollisionDetector.remove_actor"></a></p>
<h4 id="remove_actor_2">remove_actor<a class="headerlink" href="#remove_actor_2" title="Permanent link">&para;</a></h4>
<pre><code class="language-python"> | remove_actor(actor: Actor) -&gt; None
</code></pre>
<p>Remore an actor from the detector and all collision groups</p>
<p><strong>Arguments</strong>:</p>
<ul>
<li><code>actor</code> <em>Actor</em> - actor to remove</li>
</ul>
<p><a name="pgz.utils.collision_detector.CollisionDetector.get_actor"></a></p>
<h4 id="get_actor_1">get_actor<a class="headerlink" href="#get_actor_1" title="Permanent link">&para;</a></h4>
<pre><code class="language-python"> | get_actor(uuid: str) -&gt; Actor
</code></pre>
<p>Get actor by UUID</p>
<p><strong>Arguments</strong>:</p>
<ul>
<li><code>uuid</code> <em>str</em> - UUID of the actor</li>
</ul>
<p><strong>Returns</strong>:</p>
<ul>
<li><code>Actor</code> - actor associated with the UUID</li>
</ul>
<p><a name="pgz.utils.collision_detector.CollisionDetector.get_actors"></a></p>
<h4 id="get_actors_1">get_actors<a class="headerlink" href="#get_actors_1" title="Permanent link">&para;</a></h4>
<pre><code class="language-python"> | get_actors() -&gt; List[Actor]
</code></pre>
<p>Get list of all the known actors.</p>
<p><strong>Returns</strong>:</p>
<ul>
<li><code>List[Actor]</code> - list of actors</li>
</ul>
<p><a name="pgz.utils.collision_detector.CollisionDetector.collide_group"></a></p>
<h4 id="collide_group_1">collide_group<a class="headerlink" href="#collide_group_1" title="Permanent link">&para;</a></h4>
<pre><code class="language-python"> | collide_group(sprite: pygame.sprite.Sprite, group_name: str = &quot;&quot;) -&gt; Optional[pygame.sprite.Sprite]
</code></pre>
<p>Detect a collision of an actor with a specified collsion group.</p>
<p><strong>Arguments</strong>:</p>
<ul>
<li><code>sprite</code> <em>pygame.sprite.Sprite</em> - actor to use for collision detection.</li>
<li><code>group_name</code> <em>str, optional</em> - collision group name. Defaults to &ldquo;&rdquo;.</li>
</ul>
<p><strong>Returns</strong>:</p>
<ul>
<li><code>Optional[pygame.sprite.Sprite]</code> - actor was found in the collsion group.</li>
</ul>
<p><a name="pgz.utils.event_dispatcher"></a></p>
<h1 id="pgzutilsevent_dispatcher">pgz.utils.event_dispatcher<a class="headerlink" href="#pgzutilsevent_dispatcher" title="Permanent link">&para;</a></h1>
<p><a name="pgz.utils.event_dispatcher.EventDispatcher"></a></p>
<h2 id="eventdispatcher">EventDispatcher<a class="headerlink" href="#eventdispatcher" title="Permanent link">&para;</a></h2>
<pre><code class="language-python">class EventDispatcher()
</code></pre>
<p>Adapt a pgzero game&rsquo;s raw handler function to take a Pygame Event.</p>
<p>Returns a one-argument function of the form <code>handler(event)</code>.
This will ensure that the correct arguments are passed to the raw
handler based on its argument spec.</p>
<p>The wrapped handler will also map certain parameter values using
callables from EVENT_PARAM_MAPPERS; this ensures that the value of
&lsquo;button&rsquo; inside the handler is a real instance of constants.mouse,
which means (among other things) that it will print as a symbolic value
rather than a naive integer.</p>
<p><a name="pgz.utils.event_dispatcher.EventDispatcher.handle_event"></a></p>
<h4 id="handle_event_4">handle_event<a class="headerlink" href="#handle_event_4" title="Permanent link">&para;</a></h4>
<pre><code class="language-python"> | handle_event(event: pygame.event.Event) -&gt; None
</code></pre>
<p>Override me</p>
<p><a name="pgz.utils.fps_calc"></a></p>
<h1 id="pgzutilsfps_calc">pgz.utils.fps_calc<a class="headerlink" href="#pgzutilsfps_calc" title="Permanent link">&para;</a></h1>
<p><a name="pgz.utils.scroll_map"></a></p>
<h1 id="pgzutilsscroll_map">pgz.utils.scroll_map<a class="headerlink" href="#pgzutilsscroll_map" title="Permanent link">&para;</a></h1>
<p><a name="pgz.utils.scroll_map.ScrollMap"></a></p>
<h2 id="scrollmap">ScrollMap<a class="headerlink" href="#scrollmap" title="Permanent link">&para;</a></h2>
<pre><code class="language-python">class ScrollMap(object)
</code></pre>
<p>Scroll Map object.</p>
<p>The implementation is based on <a href="https://github.com/bitcraft/pyscroll">pyscroll</a></p>
<p>This class provides functionality:
- create and manage a pyscroll group
- load a collision layers
- manage sprites added to the map
- allows to detect collisions with loaded collision layers
- render the map and the sprites on top</p>
<p><a name="pgz.utils.scroll_map.ScrollMap.__init__"></a></p>
<h4 id="__init___7">__init__<a class="headerlink" href="#__init___7" title="Permanent link">&para;</a></h4>
<pre><code class="language-python"> | __init__(screen_size: Tuple[int, int], tmx: pytmx.TiledMap, collision_layers: List[str] = []) -&gt; None
</code></pre>
<p>Create scroll map object.</p>
<p><strong>Arguments</strong>:</p>
<ul>
<li><code>screen_size</code> <em>Tuple[int, int]</em> - screen resolution will be used to the map rendering</li>
<li><code>tmx</code> <em>pytmx.TiledMap</em> - loaded <code>pytmx.TiledMap</code> object</li>
<li><code>collision_layers</code> <em>List[str], optional</em> - List of <code>pytmx.TiledMap</code> layer names will be used for tiles collision detection. Defaults to [].</li>
</ul>
<p><a name="pgz.utils.scroll_map.ScrollMap.add_collision_layers"></a></p>
<h4 id="add_collision_layers">add_collision_layers<a class="headerlink" href="#add_collision_layers" title="Permanent link">&para;</a></h4>
<pre><code class="language-python"> | add_collision_layers(collision_layers: List[str]) -&gt; None
</code></pre>
<p>Load <code>pytmx.TiledMap</code> layer tiles for collision detection.</p>
<p>Some layer in the <code>pytmx.TiledMap</code> might be be used for collision detection.
For example: the layer includes &ldquo;island tiles&rdquo; might be used for collision detection with a &ldquo;ship&rdquo; actor.</p>
<p><strong>Arguments</strong>:</p>
<ul>
<li><code>collision_layers</code> <em>List[str]</em> - List of <code>pytmx.TiledMap</code> layer names will be used for tiles collision detection.</li>
</ul>
<p><a name="pgz.utils.scroll_map.ScrollMap.draw"></a></p>
<h4 id="draw_5">draw<a class="headerlink" href="#draw_5" title="Permanent link">&para;</a></h4>
<pre><code class="language-python"> | draw(screen: Screen) -&gt; None
</code></pre>
<p>Draw method similar to the <code>pgz.scene.Scene.draw</code> method.</p>
<p>Will draw the map and all actors on top.</p>
<p><strong>Arguments</strong>:</p>
<ul>
<li><code>dt</code> <em>float</em> - time in milliseconds since the last update</li>
</ul>
<p><a name="pgz.utils.scroll_map.ScrollMap.update"></a></p>
<h4 id="update_5">update<a class="headerlink" href="#update_5" title="Permanent link">&para;</a></h4>
<pre><code class="language-python"> | update(dt: float) -&gt; None
</code></pre>
<p>Update method similar to the <code>pgz.scene.Scene.update</code> method.</p>
<p>All the actors attached to the map will be updated.</p>
<p><strong>Arguments</strong>:</p>
<ul>
<li><code>dt</code> <em>float</em> - time in milliseconds since the last update</li>
</ul>
<p><a name="pgz.utils.scroll_map.ScrollMap.add_sprite"></a></p>
<h4 id="add_sprite">add_sprite<a class="headerlink" href="#add_sprite" title="Permanent link">&para;</a></h4>
<pre><code class="language-python"> | add_sprite(sprite: pygame.sprite.Sprite) -&gt; None
</code></pre>
<p>Add actor/sprite to the map</p>
<p><strong>Arguments</strong>:</p>
<ul>
<li><code>sprite</code> <em>pygame.sprite.Sprite</em> - sprite object to add</li>
</ul>
<p><a name="pgz.utils.scroll_map.ScrollMap.remove_sprite"></a></p>
<h4 id="remove_sprite">remove_sprite<a class="headerlink" href="#remove_sprite" title="Permanent link">&para;</a></h4>
<pre><code class="language-python"> | remove_sprite(sprite: pygame.sprite.Sprite) -&gt; None
</code></pre>
<p>Remove sprite/actor from the map.</p>
<p><strong>Arguments</strong>:</p>
<ul>
<li><code>sprite</code> <em>pygame.sprite.Sprite</em> - sprite object to remove</li>
</ul>
<p><a name="pgz.utils.scroll_map.ScrollMap.collide_map"></a></p>
<h4 id="collide_map_1">collide_map<a class="headerlink" href="#collide_map_1" title="Permanent link">&para;</a></h4>
<pre><code class="language-python"> | collide_map(sprite: pygame.sprite.Sprite) -&gt; bool
</code></pre>
<p>Detect a collision with tiles on the map</p>
<p><strong>Arguments</strong>:</p>
<ul>
<li><code>sprite</code> <em>pygame.sprite.Sprite</em> - sprite/actor for detection</li>
</ul>
<p><strong>Returns</strong>:</p>
<ul>
<li><code>bool</code> - True is the collision with the colision layers was detected</li>
</ul></div>
            </div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script>
            var base_url = "..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../js/base.js" defer></script>
        <script src="../search/main.js" defer></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
                <p>
                    From here you can search these documents. Enter
                    your search terms below.
                </p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
