<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="None">
  
  
  <link rel="shortcut icon" href="img/favicon.ico">
  <title>pgz</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700" />

  <link rel="stylesheet" href="css/theme.css" />
  <link rel="stylesheet" href="css/theme_extra.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" />
  
  <script>
    // Current page data
    var mkdocs_page_name = "Home";
    var mkdocs_page_input_path = "index.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="js/jquery-2.1.1.min.js" defer></script>
  <script src="js/modernizr-2.8.3.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
        <a href="." class="icon icon-home"> pgz</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="./search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
                <ul class="current">
                    <li class="toctree-l1 current"><a class="reference internal current" href=".">Home</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#features">Features</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#installation">Installation</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#quick-start">Quick start</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#application">Application</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#scene">Scene</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#actors">Actors</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#mapscene">MapScene</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#map-loading">Map loading</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#map-management-and-rendering">Map management and rendering</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#game-example">Game example</a>
    </li>
    </ul>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="api-documentation/">API Documentation</a>
                    </li>
                </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href=".">pgz</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href=".">Docs</a> &raquo;</li>
    
      
    
    <li>Home</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="pgz">pgz</h1>
<p>pgz aim to make development of advanced <a href="https://www.pygame.org/">pygame</a> games easier.
pgz uses pgzero as infrastructure intensively, but makes the experience more object oriented.</p>
<h2 id="features">Features</h2>
<ul>
<li>More pytonic infrastructure: pgz utilies a lot of features from <a href="https://github.com/lordmauve/pgzero">pgzero</a></li>
<li>Multi-scene games: The idea and some code was taken from <a href="https://github.com/Mahi/EzPyGame">EzPyGame</a></li>
<li>Maps, collision detection and maps scrolling: the implementation is based on <a href="https://github.com/bitcraft/pyscroll">pyscroll</a></li>
<li>Scenes for rendering Menu based <a href="https://github.com/ppizarror/pygame-menu">pygame-menu</a></li>
<li>Multi-player game over network: based on simple RPC over WebSockets</li>
</ul>
<h2 id="installation">Installation</h2>
<p>not yet</p>
<h2 id="quick-start">Quick start</h2>
<p>pgz heavily uses concepts and some code of <a href="https://github.com/Mahi/EzPyGame">EzPyGame</a> and <a href="https://github.com/lordmauve/pgzero">pgzero</a>.
pgz game entry point is application, application renders scene, scene can be changed, scene manages actors.</p>
<p>So pgz operates by 3 main concepts:</p>
<ul>
<li>Application</li>
<li>Scene</li>
<li>Actor</li>
</ul>
<h3 id="application">Application</h3>
<p>The application and scenes idea was from the <a href="https://github.com/Mahi/EzPyGame">EzPyGame</a>.</p>
<p>Example of pgz application start:</p>
<pre><code>if __name__ == &quot;__main__&quot;:

    app = pgz.Application(
        title=&quot;pgz Standalone Demo&quot;,
        resolution=(1280, 720),
        update_rate=60,
    )

    try:
        scene = ....
        app.run(scene)

    except Exception:
        # pygame.quit()
        raise
</code></pre>
<h3 id="scene">Scene</h3>
<p>In the snippet above scene object instantiation <code>scene = ....</code> was skipped.</p>
<p>The application and scenes idea was from the  <a href="https://github.com/Mahi/EzPyGame">EzPyGame</a>.</p>
<p>Scene is the core of your game, but the active scene of you game can be changed, when you need to change the game behavior.
Bassically the pgz.Application delegates all the events processing and rendering logic to the active scene.</p>
<p>If the pgz.Application is not require subclassing, the usage of scenes is based on the subclassing idea.
There are a few important method to override in pgz.Scene:</p>
<ul>
<li><code>handle_event(self, event: pygame.event.Event)</code> - for processing pygame events</li>
<li><code>draw(self, screen: pgz.Screen)</code> - for rendering of the scene screen</li>
<li><code>update(self, dt: float)</code> - for modifying the scene state</li>
<li><code>on_enter(self, previous_scene: pgz.Scene)</code> - for initialization of the scene</li>
<li><code>on_exit(self, next_scene: pgz.Scene)</code> - for initialization of the scene</li>
</ul>
<pre><code>class Game(Scene):
    ...

    def on_enter(self, previous_scene):
        self.previous_scene = previous_scene

    def update(self, dt):
        self.player.move(dt)
        if self.player.died():
            self.application.change_scene(self.previous_scene)
</code></pre>
<p>Good news that pgz provides a few pgz.Scene derived scenes for common use cases. So you can subclass from the scene implementation, which is more suitable for your game:</p>
<ul>
<li><code>pgz.MenuScene</code> - implements game menu rendering as a pgz.Scene subclass</li>
<li><code>pgz.ActorScene</code> - implements the basic actors managements, updates, rendering logic and actors collision detection.</li>
<li><code>pgz.MapScene</code> - extends pgz.ActorScene for games based on the tiled maps. It also implements the tiles collision detection.</li>
<li><code>pgz.RemoteScene</code> - allows to render the view of remote pgz.MapScene or pgz.ActorScene using WebSocket connection. It might be useful handy for building of a multiplayer game</li>
</ul>
<h3 id="actors">Actors</h3>
<p>Actor concept was inspired from <a href="https://github.com/lordmauve/pgzero">pgzero</a>.
Actor is a sprite:</p>
<pre><code>alien = Actor('alien')
alien.pos = 100, 56
</code></pre>
<p>The subclassing from the actor may be a good idea for building of the more complicated logic:</p>
<pre><code>class Ship(pgz.Actor):
    def __init__(self) -&gt; None:
        super().__init__(random.choice([&quot;ship (1)&quot;, &quot;ship (2)&quot;, &quot;ship (3)&quot;, &quot;ship (4)&quot;, &quot;ship (5)&quot;, &quot;ship (6)&quot;]))

    def update(self, dt):
        self._old_pos = self.pos[:]

        if self.keyboard.up:
            self.velocity[1] = -self.speed
        elif self.keyboard.down:
            self.velocity[1] = self.speed
        else:
            self.velocity[1] = 0

        if self.keyboard.left:
            self.velocity[0] = -self.speed
        elif self.keyboard.right:
            self.velocity[0] = self.speed
        else:
            self.velocity[0] = 0

        self.x += self.velocity[0] * dt
        self.y += self.velocity[1] * dt

    def move_back(self, dt):
        &quot;&quot;&quot;If called after an update, the sprite can move back&quot;&quot;&quot;
        self.pos = self._old_pos[:]
</code></pre>
<p>Two important methods for overriding are:</p>
<pre><code>    def draw(self, screen: Screen) -&gt; None:
        pass

    def update(self, dt: float) -&gt; None:
        pass
</code></pre>
<p>Once actor is constructed in can be attached to ActorScene and the scene will take care of calling draw and update methods:</p>
<pre><code>scene.add_actor(ship)
</code></pre>
<h2 id="mapscene">MapScene</h2>
<p>The usage of pgz.MapScene will require the instantiation of a map object. pgz provides a way for loading and handling <a href="https://www.mapeditor.org/">Tiled</a> maps.</p>
<h3 id="map-loading">Map loading</h3>
<p>The map object loading is done with the map loader (a-la pgzero resource loaders). So for loading a map from "default.tmx" file of the resource directory: </p>
<pre><code>tmx = pgz.maps.default
</code></pre>
<p>The "mtx" files can be created and modified with wonderful <a href="https://www.mapeditor.org/">Tiled</a> mps editor.</p>
<h3 id="map-management-and-rendering">Map management and rendering</h3>
<p>The maps loading and usage is backed by <a href="https://github.com/bitcraft/pyscroll">pyscroll</a></p>
<p>pgz provides a pgz.ScrollMap class which covers listed functionality:
- create and manage a pyscroll group
- load a collision layers
- manage sprites added to the map
- allows to detect collisions with loaded collision layers
- render the map and the sprites on top</p>
<p>The code example will load tiled map, instantiate a pgz.ScrollMap object and initialize "Islands" layer of the tmx map as a collision layer.</p>
<pre><code>tmx = pgz.maps.default
map = pgz.ScrollMap(app.resolution, tmx, [&quot;Islands&quot;])
</code></pre>
<p>Once the map object is initialized it can be used with pgz.MapScene:</p>
<pre><code>scene = pgz.MapScene(map)
scene.add_actor(ship)

...
if scene.collide_map(ship):
    print(&quot;I found an island!&quot;)
</code></pre>
<p>A more complete example of the pgz.MapScene subclassing:</p>
<pre><code>class Game(pgz.MapScene):
    def __init__(self, map):
        super().__init__(map)

        self.ship = Ship()
        # put the ship in the center of the map
        self.ship.position = self.map.get_center()
        self.ship.x += 600
        self.ship.y += 400

        # add our ship to the group
        self.add_actor(self.ship, central_actor=True)

    def update(self, dt):
        self.map.update(dt)

        if self.map.collide_map(self.ship):
            self.ship.move_back(dt)

    def on_mouse_move(self, pos):
        angle = self.ship.angle_to(pos) + 90
        self.ship.angle = angle

    def on_mouse_down(self, pos, button):
        ball = CannonBall(self.ship.pos, pos, self.remove_actor)
        self.add_actor(ball)

    def on_key_down(self, key):
        if key == pygame.K_EQUALS:
            self.map.change_zoom(0.25)
        elif key == pygame.K_MINUS:
            self.map.change_zoom(-0.25)
</code></pre>
<h2 id="game-example">Game example</h2>
<p>The game example which utilizes using all the described concepts, can be fount in demo/demo_standalone.py</p>
<h1 id="multiplayer-game-with-pgz">Multiplayer game with pgz</h1>
<p>pgz provides two key components for converting your single-player into multiplayer-game over the network:</p>
<ul>
<li>pgz.MultiplayerSceneServer</li>
<li>pgz.RemoteScene</li>
</ul>
<h2 id="multiplayer-game-server">Multiplayer game server</h2>
<p>MultiplayerSceneServer opens a WebSocket server and instantiate a pgz.Scene per connected player(client):</p>
<pre><code>tmx = pgz.maps.default
map = pgz.ScrollMap((1280, 720), tmx, [&quot;Islands&quot;])

# Build and start game server
self.server = pgz.MultiplayerSceneServer(map, GameScene)
self.server.start_server(port=self.port)
</code></pre>
<p>All the scenes will share the map object and collision detector object. So, the communication between different players scenes is done with collision detection.
If one scene shoots the cannon ball (by implementing the CannonBall actor and adding its instance to the map):</p>
<pre><code>def on_mouse_down(self, pos, button):
    start_point = self.calc_cannon_ball_start_pos(pos)
    if start_point:
        ball = CannonBall(pos=start_point, target=pos)
        self.add_actor(ball, group_name=&quot;cannon_balls&quot;)
</code></pre>
<p>Another player(scene) might be harmed by the cannon ball using the collision detection:</p>
<pre><code>def update(self, dt):
    super().update(dt)

    cannon_ball = self.collide_group(self.ship, &quot;cannon_balls&quot;)
    if cannon_ball:
        # pgz.sounds.arrr.play()
        self.ship.health -= cannon_ball.hit_rate * dt
</code></pre>
<h2 id="multiplayer-game-client">Multiplayer game client</h2>
<p>pgz.RemoteScene allows to communicate with pgz.MultiplayerSceneServer and render the remote scene locally:</p>
<pre><code>data = self.menu.get_input_data()
server_url = data[&quot;server_url&quot;]

tmx = pgz.maps.default
map = pgz.ScrollMap(app.resolution, tmx, [&quot;Islands&quot;])
game = pgz.RemoteScene(map, server_url, client_data={&quot;name&quot;: data[&quot;name&quot;]})
</code></pre>
<p>Pay attention that client process needs to have access to the same external resources (like map files, images,...) as the game server.</p>
<h2 id="multiplayer-game-example">Multiplayer game example</h2>
<p>The multiplayer game example can be found in demo/demo_server.py and demo/demo_client.py</p>
<h2 id="demo">Demo</h2>
<p><img alt="Alt Text" src="img/demo.gif" /></p>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="api-documentation/" class="btn btn-neutral float-right" title="API Documentation">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
      
        <span style="margin-left: 15px"><a href="api-documentation/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>
    <script>var base_url = '.';</script>
    <script src="js/theme.js" defer></script>
      <script src="search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>

<!--
MkDocs version : 1.1.2
Build Date UTC : 2020-11-08 17:51:04.786694+00:00
-->
